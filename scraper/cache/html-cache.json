{"/x86/aaa":{"name":"AAA","description":"ASCII Adjust After Addition","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AAA\n\t\t— ASCII Adjust After Addition</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AAA\n\t\t— ASCII Adjust After Addition</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>37</td>\n<td>AAA</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>ASCII adjust AL after addition.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>ZO</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adjusts the sum of two unpacked BCD values to create an unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAA instruction is only useful when it follows an ADD instruction that adds (binary addition) two unpacked BCD values and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p>\n<p>If the addition produces a decimal carry, the AH register increments by 1, and the CF and AF flags are set. If there was no decimal carry, the CF and AF flags are cleared and the AH register is unchanged. In either case, bits 4 through 7 of the AL register are set to 0.</p>\n<p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        IF ((AL AND 0FH) &gt; 9) or (AF = 1)\n            THEN\n                AX := AX + 106H;\n                AF := 1;\n                CF := 1;\n            ELSE\n                AF := 0;\n                CF := 0;\n        FI;\n        AL := AL AND 0FH;\nFI;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AF and CF flags are set to 1 if the adjustment results in a decimal carry; otherwise they are set to 0. The OF, SF, ZF, and PF flags are undefined.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If in 64-bit mode.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aaa"},"/x86/aad":{"name":"AAD","description":"ASCII Adjust AX Before Division","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AAD\n\t\t— ASCII Adjust AX Before Division</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AAD\n\t\t— ASCII Adjust AX Before Division</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>D5 0A</td>\n<td>AAD</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>ASCII adjust AX before division.</td></tr>\n<tr>\n<td>D5 ib</td>\n<td>AAD imm8</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>Adjust AX before division to number base imm8.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>ZO</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adjusts two unpacked BCD digits (the least-significant digit in the AL register and the most-significant digit in the AH register) so that a division operation performed on the result will yield a correct unpacked BCD value. The AAD instruction is only useful when it precedes a DIV instruction that divides (binary division) the adjusted value in the AX register by an unpacked BCD value.</p>\n<p>The AAD instruction sets the value in the AL register to (AL + (10 * AH)), and then clears the AH register to 00H. The value in the AX register is then equal to the binary equivalent of the original unpacked two-digit (base 10) number in registers AH and AL.</p>\n<p>The generalized version of this instruction allows adjustment of two unpacked digits of any number base (see the “Operation” section below), by setting the <em>imm8</em> byte to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAD mnemonic is interpreted by all assemblers to mean adjust ASCII (base 10) values. To adjust values in another number base, the instruction must be hand coded in machine code (D5 <em>imm8</em>).</p>\n<p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        tempAL := AL;\n        tempAH := AH;\n        AL := (tempAL + (tempAH ∗ <em>imm8</em>)) AND FFH;\n        (* <em>imm8</em> is set to 0AH for the AAD mnemonic.*)\n        AH := 0;\nFI;\nThe immediate value (<em>imm8</em>) is taken from the second byte of the instruction.\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The SF, ZF, and PF flags are set according to the resulting binary value in the AL register; the OF, AF, and CF flags are undefined.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If in 64-bit mode.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aad"},"/x86/aam":{"name":"AAM","description":"ASCII Adjust AX After Multiply","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AAM\n\t\t— ASCII Adjust AX After Multiply</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AAM\n\t\t— ASCII Adjust AX After Multiply</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>D4 0A</td>\n<td>AAM</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>ASCII adjust AX after multiply.</td></tr>\n<tr>\n<td>D4 ib</td>\n<td>AAM imm8</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>Adjust AX after multiply to number base imm8.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>ZO</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adjusts the result of the multiplication of two unpacked BCD values to create a pair of unpacked (base 10) BCD values. The AX register is the implied source and destination operand for this instruction. The AAM instruction is only useful when it follows an MUL instruction that multiplies (binary multiplication) two unpacked BCD values and stores a word result in the AX register. The AAM instruction then adjusts the contents of the AX register to contain the correct 2-digit unpacked (base 10) BCD result.</p>\n<p>The generalized version of this instruction allows adjustment of the contents of the AX to create two unpacked digits of any number base (see the “Operation” section below). Here, the <em>imm8</em> byte is set to the selected number base (for example, 08H for octal, 0AH for decimal, or 0CH for base 12 numbers). The AAM mnemonic is interpreted by all assemblers to mean adjust to ASCII (base 10) values. To adjust to values in another number base, the instruction must be hand coded in machine code (D4 <em>imm8</em>).</p>\n<p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF 64-Bit Mode\n    THEN\n        #UD;\n    ELSE\n        tempAL := AL;\n        AH := tempAL / <em>imm8</em>; (* <em>imm8</em> is set to 0AH for the AAM mnemonic *)\n        AL := tempAL MOD <em>imm8</em>;\nFI;\nThe immediate value (<em>imm8</em>) is taken from the second byte of the instruction.\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The SF, ZF, and PF flags are set according to the resulting binary value in the AL register. The OF, AF, and CF flags are undefined.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#DE</td>\n<td>If an immediate value of 0 is used.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If in 64-bit mode.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aam"},"/x86/aas":{"name":"AAS","description":"ASCII Adjust AL After Subtraction","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AAS\n\t\t— ASCII Adjust AL After Subtraction</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AAS\n\t\t— ASCII Adjust AL After Subtraction</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>3F</td>\n<td>AAS</td>\n<td>ZO</td>\n<td>Invalid</td>\n<td>Valid</td>\n<td>ASCII adjust AL after subtraction.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>ZO</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adjusts the result of the subtraction of two unpacked BCD values to create a unpacked BCD result. The AL register is the implied source and destination operand for this instruction. The AAS instruction is only useful when it follows a SUB instruction that subtracts (binary subtraction) one unpacked BCD value from another and stores a byte result in the AL register. The AAA instruction then adjusts the contents of the AL register to contain the correct 1-digit unpacked BCD result.</p>\n<p>If the subtraction produced a decimal carry, the AH register decrements by 1, and the CF and AF flags are set. If no decimal carry occurred, the CF and AF flags are cleared, and the AH register is unchanged. In either case, the AL register is left with its top four bits set to 0.</p>\n<p>This instruction executes as described in compatibility mode and legacy mode. It is not valid in 64-bit mode.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF 64-bit mode\n    THEN\n        #UD;\n    ELSE\n        IF ((AL AND 0FH) &gt; 9) or (AF = 1)\n            THEN\n                AX := AX – 6;\n                AH := AH – 1;\n                AF := 1;\n                CF := 1;\n                AL := AL AND 0FH;\n            ELSE\n                CF := 0;\n                AF := 0;\n                AL := AL AND 0FH;\n        FI;\nFI;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AF and CF flags are set to 1 if there is a decimal borrow; otherwise, they are cleared to 0. The OF, SF, ZF, and PF flags are undefined.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If in 64-bit mode.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aas"},"/x86/adc":{"name":"ADC","description":"Add With Carry","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADC\n\t\t— Add With Carry</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADC\n\t\t— Add With Carry</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>14 ib</td>\n<td>ADC AL, imm8</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry imm8 to AL.</td></tr>\n<tr>\n<td>15 iw</td>\n<td>ADC AX, imm16</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry imm16 to AX.</td></tr>\n<tr>\n<td>15 id</td>\n<td>ADC EAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry imm32 to EAX.</td></tr>\n<tr>\n<td>REX.W + 15 id</td>\n<td>ADC RAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with carry imm32 sign extended to 64-bits to RAX.</td></tr>\n<tr>\n<td>80 /2 ib</td>\n<td>ADC r/m8, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry imm8 to r/m8.</td></tr>\n<tr>\n<td>REX + 80 /2 ib</td>\n<td>ADC r/m8<sup>*</sup>, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with carry imm8 to r/m8.</td></tr>\n<tr>\n<td>81 /2 iw</td>\n<td>ADC r/m16, imm16</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry imm16 to r/m16.</td></tr>\n<tr>\n<td>81 /2 id</td>\n<td>ADC r/m32, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with CF imm32 to r/m32.</td></tr>\n<tr>\n<td>REX.W + 81 /2 id</td>\n<td>ADC r/m64, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with CF imm32 sign extended to 64-bits to r/m64.</td></tr>\n<tr>\n<td>83 /2 ib</td>\n<td>ADC r/m16, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with CF sign-extended imm8 to r/m16.</td></tr>\n<tr>\n<td>83 /2 ib</td>\n<td>ADC r/m32, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with CF sign-extended imm8 into r/m32.</td></tr>\n<tr>\n<td>REX.W + 83 /2 ib</td>\n<td>ADC r/m64, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with CF sign-extended imm8 into r/m64.</td></tr>\n<tr>\n<td>10 /r</td>\n<td>ADC r/m8, r8</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry byte register to r/m8.</td></tr>\n<tr>\n<td>REX + 10 /r</td>\n<td>ADC r/m8<sup>*</sup>, r8<sup>*</sup></td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with carry byte register to r/m64.</td></tr>\n<tr>\n<td>11 /r</td>\n<td>ADC r/m16, r16</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry r16 to r/m16.</td></tr>\n<tr>\n<td>11 /r</td>\n<td>ADC r/m32, r32</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with CF r32 to r/m32.</td></tr>\n<tr>\n<td>REX.W + 11 /r</td>\n<td>ADC r/m64, r64</td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with CF r64 to r/m64.</td></tr>\n<tr>\n<td>12 /r</td>\n<td>ADC r8, r/m8</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry r/m8 to byte register.</td></tr>\n<tr>\n<td>REX + 12 /r</td>\n<td>ADC r8<sup>*</sup>, r/m8<sup>*</sup></td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with carry r/m64 to byte register.</td></tr>\n<tr>\n<td>13 /r</td>\n<td>ADC r16, r/m16</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with carry r/m16 to r16.</td></tr>\n<tr>\n<td>13 /r</td>\n<td>ADC r32, r/m32</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add with CF r/m32 to r32.</td></tr>\n<tr>\n<td>REX.W + 13 /r</td>\n<td>ADC r64, r/m64</td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add with CF r/m64 to r64.</td></tr></table>\n<blockquote>\n<p>*In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.</p></blockquote>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MR</td>\n<td>ModRM:r/m (r, w)</td>\n<td>ModRM:reg (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MI</td>\n<td>ModRM:r/m (r, w)</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>I</td>\n<td>AL/AX/EAX/RAX</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds the destination operand (first operand), the source operand (second operand), and the carry (CF) flag and stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) The state of the CF flag represents a carry from a previous addition. When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>\n<p>The ADC instruction does not distinguish between signed or unsigned operands. Instead, the processor evaluates the result for both data types and sets the OF and CF flags to indicate a carry in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>\n<p>The ADC instruction is usually executed as part of a multibyte or multiword addition in which an ADD instruction is followed by an ADC instruction.</p>\n<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>\n<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>DEST := DEST + SRC + CF;\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>ADC extern unsigned char _addcarry_u8(unsigned char c_in, unsigned char src1, unsigned char src2, unsigned char *sum_out);\n</pre>\n<pre>ADC extern unsigned char _addcarry_u16(unsigned char c_in, unsigned short src1, unsigned short src2, unsigned short *sum_out);\n</pre>\n<pre>ADC extern unsigned char _addcarry_u32(unsigned char c_in, unsigned int src1, unsigned char int, unsigned int *sum_out);\n</pre>\n<pre>ADC extern unsigned char _addcarry_u64(unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"3\">#GP(0)</td>\n<td>If the destination is located in a non-writable segment.</td></tr>\n<tr>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP(0)</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/adc"},"/x86/adcx":{"name":"ADCX","description":"Unsigned Integer Addition of Two Operands With Carry Flag","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADCX\n\t\t— Unsigned Integer Addition of Two Operands With Carry Flag</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADCX\n\t\t— Unsigned Integer Addition of Two Operands With Carry Flag</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 F6 /r ADCX r32, r/m32</td>\n<td>RM</td>\n<td>V/V</td>\n<td>ADX</td>\n<td>Unsigned addition of r32 with CF, r/m32 to r32, writes CF.</td></tr>\n<tr>\n<td>66 REX.w 0F 38 F6 /r ADCX r64, r/m64</td>\n<td>RM</td>\n<td>V/NE</td>\n<td>ADX</td>\n<td>Unsigned addition of r64 with CF, r/m64 to r64, writes CF.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.</p>\n<p>The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).</p>\n<p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p>\n<p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.</p>\n<p>ADCX executes normally either inside or outside a transaction region.</p>\n<p>Note: ADCX defines the OF flag differently than the ADD/ADC instructions as defined in the Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF OperandSize is 64-bit\n    THEN CF:DEST[63:0] := DEST[63:0] + SRC[63:0] + CF;\n    ELSE CF:DEST[31:0] := DEST[31:0] + SRC[31:0] + CF;\nFI;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>CF is updated based on result. OF, SF, ZF, AF, and PF flags are unmodified.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>unsigned char _addcarryx_u32 (unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum_out);\n</pre>\n<pre>unsigned char _addcarryx_u64 (unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td rowspan=\"2\">#GP(0)</td>\n<td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/adcx"},"/x86/add":{"name":"ADD","description":"Add","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADD\n\t\t— Add</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADD\n\t\t— Add</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>04 ib</td>\n<td>ADD AL, imm8</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm8 to AL.</td></tr>\n<tr>\n<td>05 iw</td>\n<td>ADD AX, imm16</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm16 to AX.</td></tr>\n<tr>\n<td>05 id</td>\n<td>ADD EAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm32 to EAX.</td></tr>\n<tr>\n<td>REX.W + 05 id</td>\n<td>ADD RAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add imm32 sign-extended to 64-bits to RAX.</td></tr>\n<tr>\n<td>80 /0 ib</td>\n<td>ADD r/m8, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm8 to r/m8.</td></tr>\n<tr>\n<td>REX + 80 /0 ib</td>\n<td>ADD r/m8<sup>*</sup>, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add sign-extended imm8 to r/m8.</td></tr>\n<tr>\n<td>81 /0 iw</td>\n<td>ADD r/m16, imm16</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm16 to r/m16.</td></tr>\n<tr>\n<td>81 /0 id</td>\n<td>ADD r/m32, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add imm32 to r/m32.</td></tr>\n<tr>\n<td>REX.W + 81 /0 id</td>\n<td>ADD r/m64, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add imm32 sign-extended to 64-bits to r/m64.</td></tr>\n<tr>\n<td>83 /0 ib</td>\n<td>ADD r/m16, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add sign-extended imm8 to r/m16.</td></tr>\n<tr>\n<td>83 /0 ib</td>\n<td>ADD r/m32, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add sign-extended imm8 to r/m32.</td></tr>\n<tr>\n<td>REX.W + 83 /0 ib</td>\n<td>ADD r/m64, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add sign-extended imm8 to r/m64.</td></tr>\n<tr>\n<td>00 /r</td>\n<td>ADD r/m8, r8</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r8 to r/m8.</td></tr>\n<tr>\n<td>REX + 00 /r</td>\n<td>ADD r/m8<sup>*</sup>, r8<sup>*</sup></td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add r8 to r/m8.</td></tr>\n<tr>\n<td>01 /r</td>\n<td>ADD r/m16, r16</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r16 to r/m16.</td></tr>\n<tr>\n<td>01 /r</td>\n<td>ADD r/m32, r32</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r32 to r/m32.</td></tr>\n<tr>\n<td>REX.W + 01 /r</td>\n<td>ADD r/m64, r64</td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add r64 to r/m64.</td></tr>\n<tr>\n<td>02 /r</td>\n<td>ADD r8, r/m8</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r/m8 to r8.</td></tr>\n<tr>\n<td>REX + 02 /r</td>\n<td>ADD r8<sup>*</sup>, r/m8<sup>*</sup></td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add r/m8 to r8.</td></tr>\n<tr>\n<td>03 /r</td>\n<td>ADD r16, r/m16</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r/m16 to r16.</td></tr>\n<tr>\n<td>03 /r</td>\n<td>ADD r32, r/m32</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>Add r/m32 to r32.</td></tr>\n<tr>\n<td>REX.W + 03 /r</td>\n<td>ADD r64, r/m64</td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>Add r/m64 to r64.</td></tr></table>\n<blockquote>\n<p>*In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.</p></blockquote>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MR</td>\n<td>ModRM:r/m (r, w)</td>\n<td>ModRM:reg (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MI</td>\n<td>ModRM:r/m (r, w)</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>I</td>\n<td>AL/AX/EAX/RAX</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds the destination operand (first operand) and the source operand (second operand) and then stores the result in the destination operand. The destination operand can be a register or a memory location; the source operand can be an immediate, a register, or a memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format.</p>\n<p>The ADD instruction performs integer addition. It evaluates the result for both signed and unsigned integer operands and sets the OF and CF flags to indicate a carry (overflow) in the signed or unsigned result, respectively. The SF flag indicates the sign of the signed result.</p>\n<p>This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</p>\n<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>DEST := DEST + SRC;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The OF, SF, ZF, AF, CF, and PF flags are set according to the result.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"3\">#GP(0)</td>\n<td>If the destination is located in a non-writable segment.</td></tr>\n<tr>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP(0)</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/add"},"/x86/addpd":{"name":"ADDPD","description":"Add Packed Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDPD\n\t\t— Add Packed Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDPD\n\t\t— Add Packed Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 58 /r ADDPD xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE2</td>\n<td>Add packed double precision floating-point values from xmm2/mem to xmm1 and store result in xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F.WIG 58 /r VADDPD xmm1,xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add packed double precision floating-point values from xmm3/mem to xmm2 and store result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F.WIG 58 /r VADDPD ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add packed double precision floating-point values from ymm3/mem to ymm2 and store result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.66.0F.W1 58 /r VADDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512F</td>\n<td>Add packed double precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F.W1 58 /r VADDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512F</td>\n<td>Add packed double precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F.W1 58 /r VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512F</td>\n<td>Add packed double precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds two, four or eight packed double precision floating-point values from the first source operand to the second source operand, and stores the packed double precision floating-point result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vaddpd--evex-encoded-versions--when-src2-operand-is-a-vector-register\">VADDPD (EVEX Encoded Versions) When SRC2 Operand is a Vector Register<a class=\"anchor\" href=\"#vaddpd--evex-encoded-versions--when-src2-operand-is-a-vector-register\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+63:i] := SRC1[i+63:i] + SRC2[i+63:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaddpd--evex-encoded-versions--when-src2-operand-is-a-memory-source\">VADDPD (EVEX Encoded Versions) When SRC2 Operand is a Memory Source<a class=\"anchor\" href=\"#vaddpd--evex-encoded-versions--when-src2-operand-is-a-memory-source\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] + SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] + SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] := 0\n            FI\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaddpd--vex-256-encoded-version-\">VADDPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vaddpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[191:128] := SRC1[191:128] + SRC2[191:128]\nDEST[255:192] := SRC1[255:192] + SRC2[255:192]\nDEST[MAXVL-1:256] := 0\n.\n</pre>\n<h3 id=\"vaddpd--vex-128-encoded-version-\">VADDPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"addpd--128-bit-legacy-sse-version-\">ADDPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := DEST[63:0] + SRC[63:0]\nDEST[127:64] := DEST[127:64] + SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VADDPD __m512d _mm512_add_pd (__m512d a, __m512d b);\n</pre>\n<pre>VADDPD __m512d _mm512_mask_add_pd (__m512d s, __mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VADDPD __m512d _mm512_maskz_add_pd (__mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VADDPD __m256d _mm256_mask_add_pd (__m256d s, __mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VADDPD __m256d _mm256_maskz_add_pd (__mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VADDPD __m128d _mm_mask_add_pd (__m128d s, __mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VADDPD __m128d _mm_maskz_add_pd (__mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VADDPD __m512d _mm512_add_round_pd (__m512d a, __m512d b, int);\n</pre>\n<pre>VADDPD __m512d _mm512_mask_add_round_pd (__m512d s, __mmask8 k, __m512d a, __m512d b, int);\n</pre>\n<pre>VADDPD __m512d _mm512_maskz_add_round_pd (__mmask8 k, __m512d a, __m512d b, int);\n</pre>\n<pre>ADDPD __m256d _mm256_add_pd (__m256d a, __m256d b);\n</pre>\n<pre>ADDPD __m128d _mm_add_pd (__m128d a, __m128d b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-19</span>, “Type 2 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-46</span>, “Type E2 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addpd"},"/x86/addps":{"name":"ADDPS","description":"Add Packed Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDPS\n\t\t— Add Packed Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDPS\n\t\t— Add Packed Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>NP 0F 58 /r ADDPS xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE</td>\n<td>Add packed single precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1.</td></tr>\n<tr>\n<td>VEX.128.0F.WIG 58 /r VADDPS xmm1,xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add packed single precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.0F.WIG 58 /r VADDPS ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add packed single precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.0F.W0 58 /r VADDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512F</td>\n<td>Add packed single precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.0F.W0 58 /r VADDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512F</td>\n<td>Add packed single precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.0F.W0 58 /r VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512F</td>\n<td>Add packed single precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds four, eight or sixteen packed single precision floating-point values from the first source operand with the second source operand, and stores the packed single precision floating-point result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: the first source operand is a XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper Bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vaddps--evex-encoded-versions--when-src2-operand-is-a-register\">VADDPS (EVEX Encoded Versions) When SRC2 Operand is a Register<a class=\"anchor\" href=\"#vaddps--evex-encoded-versions--when-src2-operand-is-a-register\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)\nIF (VL = 512) AND (EVEX.b = 1)\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN DEST[i+31:i] := SRC1[i+31:i] + SRC2[i+31:i]\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaddps--evex-encoded-versions--when-src2-operand-is-a-memory-source\">VADDPS (EVEX Encoded Versions) When SRC2 Operand is a Memory Source<a class=\"anchor\" href=\"#vaddps--evex-encoded-versions--when-src2-operand-is-a-memory-source\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b = 1)\n                THEN\n                    DEST[i+31:i] :=\n                        SRC1[i+31:i] + SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] :=\n                        SRC1[i+31:i] + SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking*\n                            ; merging-masking\n                THEN *DEST[i+31:i]\n                        remains unchanged*\n                ELSE\n                            ; zeroing-masking\n                    DEST[i+31:i] :=\n                        0\n            FI\n    FI;\nENDFOR;\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaddps--vex-256-encoded-version-\">VADDPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vaddps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[159:128] := SRC1[159:128] + SRC2[159:128]\nDEST[191:160]:= SRC1[191:160] + SRC2[191:160]\nDEST[223:192] := SRC1[223:192] + SRC2[223:192]\nDEST[255:224] := SRC1[255:224] + SRC2[255:224].\nDEST[MAXVL-1:256] := 0\n</pre>\n<h3 id=\"vaddps--vex-128-encoded-version-\">VADDPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"addps--128-bit-legacy-sse-version-\">ADDPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] + SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VADDPS __m512 _mm512_add_ps (__m512 a, __m512 b);\n</pre>\n<pre>VADDPS __m512 _mm512_mask_add_ps (__m512 s, __mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VADDPS __m512 _mm512_maskz_add_ps (__mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VADDPS __m256 _mm256_mask_add_ps (__m256 s, __mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VADDPS __m256 _mm256_maskz_add_ps (__mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VADDPS __m128 _mm_mask_add_ps (__m128d s, __mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VADDPS __m128 _mm_maskz_add_ps (__mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VADDPS __m512 _mm512_add_round_ps (__m512 a, __m512 b, int);\n</pre>\n<pre>VADDPS __m512 _mm512_mask_add_round_ps (__m512 s, __mmask16 k, __m512 a, __m512 b, int);\n</pre>\n<pre>VADDPS __m512 _mm512_maskz_add_round_ps (__mmask16 k, __m512 a, __m512 b, int);\n</pre>\n<pre>ADDPS __m256 _mm256_add_ps (__m256 a, __m256 b);\n</pre>\n<pre>ADDPS __m128 _mm_add_ps (__m128 a, __m128 b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-19</span>, “Type 2 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-46</span>, “Type E2 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addps"},"/x86/addsd":{"name":"ADDSD","description":"Add Scalar Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDSD\n\t\t— Add Scalar Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDSD\n\t\t— Add Scalar Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F2 0F 58 /r ADDSD xmm1, xmm2/m64</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE2</td>\n<td>Add the low double precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.LIG.F2.0F.WIG 58 /r VADDSD xmm1, xmm2, xmm3/m64</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add the low double precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.LLIG.F2.0F.W1 58 /r VADDSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512F</td>\n<td>Add the low double precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Tuple1 Scalar</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds the low double precision floating-point values from the second source operand and the first source operand and stores the double precision floating-point result in the destination operand.</p>\n<p>The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.</p>\n<p>128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:64) of the corresponding destination register remain unchanged.</p>\n<p>EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:64) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.</p>\n<p>EVEX version: The low quadword element of the destination is updated according to the writemask.</p>\n<p>Software should ensure VADDSD is encoded with VEX.L=0. Encoding VADDSD with VEX.L=1 may encounter unpredictable behavior across different processor generations.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vaddsd--evex-encoded-version-\">VADDSD (EVEX Encoded Version)<a class=\"anchor\" href=\"#vaddsd--evex-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[63:0] := SRC1[63:0] + SRC2[63:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[63:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[63:0] := 0\n        FI;\nFI;\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vaddsd--vex-128-encoded-version-\">VADDSD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddsd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] + SRC2[63:0]\nDEST[127:64] := SRC1[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"addsd--128-bit-legacy-sse-version-\">ADDSD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addsd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := DEST[63:0] + SRC[63:0]\nDEST[MAXVL-1:64] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VADDSD __m128d _mm_mask_add_sd (__m128d s, __mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VADDSD __m128d _mm_maskz_add_sd (__mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VADDSD __m128d _mm_add_round_sd (__m128d a, __m128d b, int);\n</pre>\n<pre>VADDSD __m128d _mm_mask_add_round_sd (__m128d s, __mmask8 k, __m128d a, __m128d b, int);\n</pre>\n<pre>VADDSD __m128d _mm_maskz_add_round_sd (__mmask8 k, __m128d a, __m128d b, int);\n</pre>\n<pre>ADDSD __m128d _mm_add_sd (__m128d a, __m128d b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-20</span>, “Type 3 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-47</span>, “Type E3 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addsd"},"/x86/addss":{"name":"ADDSS","description":"Add Scalar Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDSS\n\t\t— Add Scalar Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDSS\n\t\t— Add Scalar Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 58 /r ADDSS xmm1, xmm2/m32</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE</td>\n<td>Add the low single precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.LIG.F3.0F.WIG 58 /r VADDSS xmm1,xmm2, xmm3/m32</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add the low single precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.LLIG.F3.0F.W0 58 /r VADDSS xmm1{k1}{z}, xmm2, xmm3/m32{er}</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512F</td>\n<td>Add the low single precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Tuple1 Scalar</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds the low single precision floating-point values from the second source operand and the first source operand, and stores the double precision floating-point result in the destination operand.</p>\n<p>The second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.</p>\n<p>128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.</p>\n<p>EVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.</p>\n<p>EVEX version: The low doubleword element of the destination is updated according to the writemask.</p>\n<p>Software should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vaddss--evex-encoded-versions-\">VADDSS (EVEX Encoded Versions)<a class=\"anchor\" href=\"#vaddss--evex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (EVEX.b = 1) AND SRC2 *is a register*\n    THEN\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(EVEX.RC);\n    ELSE\n        SET_ROUNDING_MODE_FOR_THIS_INSTRUCTION(MXCSR.RC);\nFI;\nIF k1[0] or *no writemask*\n    THEN DEST[31:0] := SRC1[31:0] + SRC2[31:0]\n    ELSE\n        IF *merging-masking* ; merging-masking\n            THEN *DEST[31:0] remains unchanged*\n            ELSE ; zeroing-masking\n                THEN DEST[31:0] := 0\n        FI;\nFI;\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vaddss-dest--src1--src2--vex-128-encoded-version-\">VADDSS DEST, SRC1, SRC2 (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddss-dest--src1--src2--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] + SRC2[31:0]\nDEST[127:32] := SRC1[127:32]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"addss-dest--src--128-bit-legacy-sse-version-\">ADDSS DEST, SRC (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addss-dest--src--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := DEST[31:0] + SRC[31:0]\nDEST[MAXVL-1:32] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VADDSS __m128 _mm_mask_add_ss (__m128 s, __mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VADDSS __m128 _mm_maskz_add_ss (__mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VADDSS __m128 _mm_add_round_ss (__m128 a, __m128 b, int);\n</pre>\n<pre>VADDSS __m128 _mm_mask_add_round_ss (__m128 s, __mmask8 k, __m128 a, __m128 b, int);\n</pre>\n<pre>VADDSS __m128 _mm_maskz_add_round_ss (__mmask8 k, __m128 a, __m128 b, int);\n</pre>\n<pre>ADDSS __m128 _mm_add_ss (__m128 a, __m128 b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-20</span>, “Type 3 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-47</span>, “Type E3 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addss"},"/x86/addsubpd":{"name":"ADDSUBPD","description":"Packed Double Precision Floating-Point Add/Subtract","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDSUBPD\n\t\t— Packed Double Precision Floating-Point Add/Subtract</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDSUBPD\n\t\t— Packed Double Precision Floating-Point Add/Subtract</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F D0 /r ADDSUBPD xmm1, xmm2/m128</td>\n<td>RM</td>\n<td>V/V</td>\n<td>SSE3</td>\n<td>Add/subtract double precision floating-point values from xmm2/m128 to xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F.WIG D0 /r VADDSUBPD xmm1, xmm2, xmm3/m128</td>\n<td>RVM</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add/subtract packed double precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F.WIG D0 /r VADDSUBPD ymm1, ymm2, ymm3/m256</td>\n<td>RVM</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add / subtract packed double precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVM</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds odd-numbered double precision floating-point values of the first source operand (second operand) with the corresponding double precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered double precision floating-point values from the second source operand from the corresponding double precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.</p>\n<p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See <a href='/x86/addsubpd#fig-3-3'>Figure 3-3</a>.</p>\n<p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p>\n<figure id=\"fig-3-3\">\n<svg style=\"width: 432.018pt; height: 151.206pt\" viewBox=\"128.824 0.0 365.015 131.005\">\n<g xmlns=\"http://www.w3.org/2000/svg\" style=\"fill: none; stroke: none\">\n<rect height=\"126.00500000000001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"360.015\" x=\"131.324\" y=\"0.0\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"144.82500000000002\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"144.82500000000002\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"144.82500000000002\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"144.82500000000002\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"288.831\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"288.831\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"288.831\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"144.006\" x=\"288.831\" y=\"25.875999999999976\"></rect>\n<path d=\"M 216.828 69.09300000000007 L 216.828 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 219.588 68.73300000000006 L 216.828 74.25300000000004 L 214.06799999999998 68.73300000000006 L 219.588 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<path d=\"M 360.834 69.09300000000007 L 360.834 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 363.594 68.73300000000006 L 360.834 74.25300000000004 L 358.074 68.73300000000006 L 363.594 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"116.90838390000019\" x=\"230.38335018\" y=\"18.14341284000011\">ADDSUBPD xmm1, xmm2/m128</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"44.009650300000146\" x=\"436.83669189000005\" y=\"43.456362040000045\">xmm2/m128</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"28.913084200000014\" x=\"202.3676\" y=\"43.456863\">[127:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"20.016750600000023\" x=\"350.82370000000003\" y=\"43.456863\">[63:0]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"32.30521139999996\" x=\"436.83669189000005\" y=\"87.03319611000006\">RESULT:</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"132.73297730000004\" x=\"150.4553\" y=\"91.83386300000006\">xmm1[127:64] + xmm2/m128[127:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"112.93223480000023\" x=\"304.3718\" y=\"91.83386300000006\">xmm1[63:0] - xmm2/m128[63:0]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"21.776816600000075\" x=\"436.83669189000005\" y=\"96.63355611000009\">xmm1</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"28.913084200000014\" x=\"202.3775\" y=\"115.48466300000007\">[127:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"20.016750600000023\" x=\"350.83346689\" y=\"115.48466300000007\">[63:0]</text></g></svg>\n<figcaption><a href='/x86/addsubpd#fig-3-3'>Figure 3-3</a>. ADDSUBPD—Packed Double Precision Floating-Point Add/Subtract</figcaption></figure>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"addsubpd--128-bit-legacy-sse-version-\">ADDSUBPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addsubpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := DEST[63:0] - SRC[63:0]\nDEST[127:64] := DEST[127:64] + SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaddsubpd--vex-128-encoded-version-\">VADDSUBPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddsubpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vaddsubpd--vex-256-encoded-version-\">VADDSUBPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vaddsubpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] - SRC2[63:0]\nDEST[127:64] := SRC1[127:64] + SRC2[127:64]\nDEST[191:128] := SRC1[191:128] - SRC2[191:128]\nDEST[255:192] := SRC1[255:192] + SRC2[255:192]\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>ADDSUBPD __m128d _mm_addsub_pd(__m128d a, __m128d b)\n</pre>\n<pre>VADDSUBPD __m256d _mm256_addsub_pd (__m256d a, __m256d b)\n</pre>\n<h2 class=\"exceptions\" id=\"exceptions\">Exceptions<a class=\"anchor\" href=\"#exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>When the source operand is a memory operand, it must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-19</span>, “Type 2 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addsubpd"},"/x86/addsubps":{"name":"ADDSUBPS","description":"Packed Single Precision Floating-Point Add/Subtract","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADDSUBPS\n\t\t— Packed Single Precision Floating-Point Add/Subtract</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADDSUBPS\n\t\t— Packed Single Precision Floating-Point Add/Subtract</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F2 0F D0 /r ADDSUBPS xmm1, xmm2/m128</td>\n<td>RM</td>\n<td>V/V</td>\n<td>SSE3</td>\n<td>Add/subtract single precision floating-point values from xmm2/m128 to xmm1.</td></tr>\n<tr>\n<td>VEX.128.F2.0F.WIG D0 /r VADDSUBPS xmm1, xmm2, xmm3/m128</td>\n<td>RVM</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add/subtract single precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.F2.0F.WIG D0 /r VADDSUBPS ymm1, ymm2, ymm3/m256</td>\n<td>RVM</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Add / subtract single precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVM</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Adds odd-numbered single precision floating-point values of the first source operand (second operand) with the corresponding single precision floating-point values from the second source operand (third operand); stores the result in the odd-numbered values of the destination operand (first operand). Subtracts the even-numbered single precision floating-point values from the second source operand from the corresponding single precision floating values in the first source operand; stores the result into the even-numbered values of the destination operand.</p>\n<p>In 64-bit mode, using a REX prefix in the form of REX.R permits this instruction to access additional registers (XMM8-XMM15).</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified. See <a href='/x86/addsubps#fig-3-4'>Figure 3-4</a>.</p>\n<p>VEX.128 encoded version: the first source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p>\n<figure id=\"fig-3-4\">\n<svg style=\"width: 432.018pt; height: 167.40719999999996pt\" viewBox=\"115.111 0.0 365.015 144.50599999999997\">\n<g xmlns=\"http://www.w3.org/2000/svg\" style=\"fill: none; stroke: none\">\n<rect height=\"139.506\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"360.015\" x=\"117.611\" y=\"0.0\"></rect>\n<path d=\"M 394.372 69.09300000000007 L 394.372 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 397.132 68.73300000000006 L 394.372 74.25300000000004 L 391.612 68.73300000000006 L 397.132 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<rect height=\"38.252\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"356.12\" y=\"74.25300000000004\"></rect>\n<rect height=\"38.252\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"356.12\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"356.12\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"356.12\" y=\"25.875999999999976\"></rect>\n<path d=\"M 317.869 69.09300000000007 L 317.869 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 320.629 68.73300000000006 L 317.869 74.25300000000004 L 315.10900000000004 68.73300000000006 L 320.629 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<rect height=\"38.252\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"279.617\" y=\"74.25300000000004\"></rect>\n<rect height=\"38.252\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"279.617\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"279.617\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"279.617\" y=\"25.875999999999976\"></rect>\n<path d=\"M 241.366 69.09300000000007 L 241.366 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 244.126 68.73300000000006 L 241.366 74.25300000000004 L 238.606 68.73300000000006 L 244.126 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<rect height=\"38.252\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"203.114\" y=\"74.25300000000004\"></rect>\n<rect height=\"38.252\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"203.114\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"203.114\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"203.114\" y=\"25.875999999999976\"></rect>\n<path d=\"M 164.862 69.09300000000007 L 164.862 52.88200000000006\" style=\"fill-rule: nonzero; stroke: rgb(0%, 0%, 0%)\"></path>\n<path d=\"M 167.623 68.73300000000006 L 164.863 74.25300000000004 L 162.10299999999998 68.73300000000006 L 167.623 68.73300000000006\" style=\"fill: rgb(0%, 0%, 0%); fill-rule: evenodd\"></path>\n<rect height=\"38.252\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"126.611\" y=\"74.25300000000004\"></rect>\n<rect height=\"38.252\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"126.611\" y=\"74.25300000000004\"></rect>\n<rect height=\"27.001\" style=\"fill: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"126.611\" y=\"25.875999999999976\"></rect>\n<rect height=\"27.001\" style=\"stroke: rgb(0%, 0%, 0%)\" width=\"76.503\" x=\"126.611\" y=\"25.875999999999976\"></rect>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"116.4683674000002\" x=\"221.3897\" y=\"18.14386300000001\">ADDSUBPS xmm1, xmm2/m128</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"24.00090000000006\" x=\"437.07378785000003\" y=\"38.65743223000004\">xmm2/</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"28.913084200000014\" x=\"150.4017\" y=\"43.456863\">[127:96]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"24.46491740000002\" x=\"229.135\" y=\"43.456863\">[95:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"24.464917400000047\" x=\"305.6381\" y=\"43.456863\">[63:32]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"20.016750600000023\" x=\"384.3613\" y=\"43.456863\">[31:0]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"20.008750300000088\" x=\"437.07378785000003\" y=\"48.257792230000064\">m128</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"32.30521139999996\" x=\"437.07378785000003\" y=\"92.65945723000004\">RESULT:</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"52.55836626360113\" x=\"139.5214\" y=\"92.58567721807572\">xmm1[127:96] +</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"70.42132331726216\" x=\"207.3341\" y=\"92.58567721807572\">xmm1[95:64] - xmm2/</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"48.51457826360098\" x=\"294.4876\" y=\"92.58567721807572\">xmm1[63:32] +</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"42.55616558866285\" x=\"373.8308\" y=\"92.58567721807572\">xmm1[31:0] -</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"21.776816600000075\" x=\"437.07378785000003\" y=\"102.25981723000007\">xmm1</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"66.39208131726227\" x=\"132.7713287\" y=\"102.18603721807574\">xmm2/m128[127:96]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"40.52929331726219\" x=\"221.7950059\" y=\"102.18603721807574\">m128[95:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"62.34829331726206\" x=\"287.7375287\" y=\"102.18603721807574\">xmm2/m128[63:32]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.063515733038685pt; fill: #000\" textLength=\"58.304505317262056\" x=\"366.2006957\" y=\"102.18603721807574\">xmm2/m128[31:0]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"28.913084200000014\" x=\"150.41210039\" y=\"125.53514082000004\">[127:96]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"24.46491740000002\" x=\"229.14545278000003\" y=\"125.53514082000004\">[95:64]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"24.464917400000047\" x=\"305.64832153000003\" y=\"125.53514082000004\">[63:32]</text>\n<text lengthAdjust=\"spacingAndGlyphs\" style=\"font-size: 7.408277799999951pt; fill: #000\" textLength=\"20.016750600000023\" x=\"384.3712735300001\" y=\"125.53514082000004\">[31:0]</text></g></svg>\n<figcaption><a href='/x86/addsubps#fig-3-4'>Figure 3-4</a>. ADDSUBPS—Packed Single Precision Floating-Point Add/Subtract</figcaption></figure>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"addsubps--128-bit-legacy-sse-version-\">ADDSUBPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#addsubps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := DEST[31:0] - SRC[31:0]\nDEST[63:32] := DEST[63:32] + SRC[63:32]\nDEST[95:64] := DEST[95:64] - SRC[95:64]\nDEST[127:96] := DEST[127:96] + SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaddsubps--vex-128-encoded-version-\">VADDSUBPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vaddsubps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vaddsubps--vex-256-encoded-version-\">VADDSUBPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vaddsubps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] - SRC2[31:0]\nDEST[63:32] := SRC1[63:32] + SRC2[63:32]\nDEST[95:64] := SRC1[95:64] - SRC2[95:64]\nDEST[127:96] := SRC1[127:96] + SRC2[127:96]\nDEST[159:128] := SRC1[159:128] - SRC2[159:128]\nDEST[191:160] := SRC1[191:160] + SRC2[191:160]\nDEST[223:192] := SRC1[223:192] - SRC2[223:192]\nDEST[255:224] := SRC1[255:224] + SRC2[255:224]\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>ADDSUBPS __m128 _mm_addsub_ps(__m128 a, __m128 b)\n</pre>\n<pre>VADDSUBPS __m256 _mm256_addsub_ps (__m256 a, __m256 b)\n</pre>\n<h2 class=\"exceptions\" id=\"exceptions\">Exceptions<a class=\"anchor\" href=\"#exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>When the source operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated.</p>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Overflow, Underflow, Invalid, Precision, Denormal.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-19</span>, “Type 2 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/addsubps"},"/x86/adox":{"name":"ADOX","description":"Unsigned Integer Addition of Two Operands With Overflow Flag","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ADOX\n\t\t— Unsigned Integer Addition of Two Operands With Overflow Flag</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ADOX\n\t\t— Unsigned Integer Addition of Two Operands With Overflow Flag</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 F6 /r ADOX r32, r/m32</td>\n<td>RM</td>\n<td>V/V</td>\n<td>ADX</td>\n<td>Unsigned addition of r32 with OF, r/m32 to r32, writes OF.</td></tr>\n<tr>\n<td>F3 REX.w 0F 38 F6 /r ADOX r64, r/m64</td>\n<td>RM</td>\n<td>V/NE</td>\n<td>ADX</td>\n<td>Unsigned addition of r64 with OF, r/m64 to r64, writes OF.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.</p>\n<p>The ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).</p>\n<p>This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.</p>\n<p>In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.</p>\n<p>ADOX executes normally either inside or outside a transaction region.</p>\n<p>Note: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in <em>Intel<sup>®</sup> 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A</em>.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF OperandSize is 64-bit\n    THEN OF:DEST[63:0] := DEST[63:0] + SRC[63:0] + OF;\n    ELSE OF:DEST[31:0] := DEST[31:0] + SRC[31:0] + OF;\nFI;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>OF is updated based on result. CF, SF, ZF, AF, and PF flags are unmodified.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>unsigned char _addcarryx_u32 (unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum_out);\n</pre>\n<pre>unsigned char _addcarryx_u64 (unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td rowspan=\"2\">#GP(0)</td>\n<td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/adox"},"/x86/aesdec":{"name":"AESDEC","description":"Perform One Round of an AES Decryption Flow","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDEC\n\t\t— Perform One Round of an AES Decryption Flow</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDEC\n\t\t— Perform One Round of an AES Decryption Flow</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 DE /r AESDEC xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.</td></tr>\n<tr>\n<td>VEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AES AVX</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>VAES</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F38.WIG DE /r VAESDEC ymm1, ymm2, ymm3/m256</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F38.WIG DE /r VAESDEC zmm1, zmm2, zmm3/m512</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512F</td>\n<td>Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full Mem</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.</p>\n<p>Use the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.</p>\n<p>VEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.</p>\n<p>The EVEX encoded form of this instruction does not support memory fault suppression.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aesdec\">AESDEC<a class=\"anchor\" href=\"#aesdec\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>STATE := SRC1;\nRoundKey := SRC2;\nSTATE := InvShiftRows( STATE );\nSTATE := InvSubBytes( STATE );\nSTATE := InvMixColumns( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaesdec--128b-and-256b-vex-encoded-versions-\">VAESDEC (128b and 256b VEX Encoded Versions)<a class=\"anchor\" href=\"#vaesdec--128b-and-256b-vex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    STATE := InvMixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaesdec--evex-encoded-version-\">VAESDEC (EVEX Encoded Version)<a class=\"anchor\" href=\"#vaesdec--evex-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    STATE := InvMixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] :=0\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESDEC __m128i _mm_aesdec (__m128i, __m128i)\n</pre>\n<pre>VAESDEC __m256i _mm256_aesdec_epi128(__m256i, __m256i);\n</pre>\n<pre>VAESDEC __m512i _mm512_aesdec_epi128(__m512i, __m512i);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded: See <span class=\"not-imported\">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdec"},"/x86/aesdec128kl":{"name":"AESDEC128KL","description":"Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-BitKey","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDEC128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-BitKey</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDEC128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker Using 128-BitKey</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 DD !(11):rrr:bbb AESDEC128KL xmm, m384</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE</td>\n<td>Decrypt xmm using 128-bit AES key indicated by handle at m384 and store result in xmm.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESDEC128KL<sup>1</sup> instruction performs 10 rounds of AES to decrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesdec128kl\">AESDEC128KL<a class=\"anchor\" href=\"#aesdec128kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128);\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES128Decrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESDEC128KL unsigned char _mm_aesdec128kl_u8(__m128i* odata, __m128i idata, const void* h);\n</pre>\n<pre>1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdec128kl"},"/x86/aesdec256kl":{"name":"AESDEC256KL","description":"Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDEC256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDEC256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker Using 256-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 DF !(11):rrr:bbb AESDEC256KL xmm, m512</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE</td>\n<td>Decrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESDEC256KL<sup>1</sup> instruction performs 14 rounds of AES to decrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesdec256kl\">AESDEC256KL<a class=\"anchor\" href=\"#aesdec256kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256);\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES256Decrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESDEC256KL unsigned char _mm_aesdec256kl_u8(__m128i* odata, __m128i idata, const void* h);\n</pre>\n<pre>1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdec256kl"},"/x86/aesdeclast":{"name":"AESDECLAST","description":"Perform Last Round of an AES Decryption Flow","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDECLAST\n\t\t— Perform Last Round of an AES Decryption Flow</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDECLAST\n\t\t— Perform Last Round of an AES Decryption Flow</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 DF /r AESDECLAST xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.</td></tr>\n<tr>\n<td>VEX.128.66.0F38.WIG DF /r VAESDECLAST xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AES AVX</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F38.WIG DF /r VAESDECLAST ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>VAES</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.66.0F38.WIG DF /r VAESDECLAST xmm1, xmm2, xmm3/m128</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F38.WIG DF /r VAESDECLAST ymm1, ymm2, ymm3/m256</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F38.WIG DF /r VAESDECLAST zmm1, zmm2, zmm3/m512</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512F</td>\n<td>Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, using four128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full Mem</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>This instruction performs the last round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.</p>\n<p>VEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.</p>\n<p>The EVEX encoded form of this instruction does not support memory fault suppression.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aesdeclast\">AESDECLAST<a class=\"anchor\" href=\"#aesdeclast\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>STATE := SRC1;\nRoundKey := SRC2;\nSTATE := InvShiftRows( STATE );\nSTATE := InvSubBytes( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaesdeclast--128b-and-256b-vex-encoded-versions-\">VAESDECLAST (128b and 256b VEX Encoded Versions)<a class=\"anchor\" href=\"#vaesdeclast--128b-and-256b-vex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaesdeclast--evex-encoded-version-\">VAESDECLAST (EVEX Encoded Version)<a class=\"anchor\" href=\"#vaesdeclast--evex-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := InvShiftRows( STATE )\n    STATE := InvSubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESDECLAST __m128i _mm_aesdeclast (__m128i, __m128i)\n</pre>\n<pre>VAESDECLAST __m256i _mm256_aesdeclast_epi128(__m256i, __m256i);\n</pre>\n<pre>VAESDECLAST __m512i _mm512_aesdeclast_epi128(__m512i, __m512i);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded: See <span class=\"not-imported\">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdeclast"},"/x86/aesdecwide128kl":{"name":"AESDECWIDE128KL","description":"Perform Ten Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDECWIDE128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDECWIDE128KL\n\t\t— Perform Ten Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 D8 !(11):001:bbb AESDECWIDE128KL m384, &lt;XMM0-7&gt;</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLEWIDE_KL</td>\n<td>Decrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operands 2—9</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:r/m (r)</td>\n<td>Implicit XMM0-7 (r, w)</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESDECWIDE128KL<sup>1</sup> instruction performs ten rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesdecwide128kl\">AESDECWIDE128KL<a class=\"anchor\" href=\"#aesdecwide128kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128);\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF Authentic == 0 {\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    XMM0 := AES128Decrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES128Decrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES128Decrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES128Decrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES128Decrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES128Decrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES128Decrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES128Decrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<p>1. Further details on Key Locker and usage of this instruction can be found here:</p>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESDECWIDE128KLunsigned char _mm_aesdecwide128kl_u8(__m128i odata[8], const __m128i idata[8], const void* h);\n</pre>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>If CPUID.19H:EBX.WIDE_KL [bit 2] = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdecwide128kl"},"/x86/aesdecwide256kl":{"name":"AESDECWIDE256KL","description":"Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESDECWIDE256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESDECWIDE256KL\n\t\t— Perform 14 Rounds of AES Decryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 D8 !(11):011:bbb AESDECWIDE256KL m512, &lt;XMM0-7&gt;</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLEWIDE_KL</td>\n<td>Decrypt XMM0-7 using 256-bit AES key indicated by handle at m512 and store each resultant block back to its corresponding register.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operands 2—9</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:r/m (r)</td>\n<td>Implicit XMM0-7 (r, w)</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESDECWIDE256KL<sup>1</sup> instruction performs 14 rounds of AES to decrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding decrypted block if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesdecwide256kl\">AESDECWIDE256KL<a class=\"anchor\" href=\"#aesdecwide256kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [2] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256);\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                XMM0 := AES256Decrypt (XMM0, UnwrappedKey) ;\n                XMM1 := AES256Decrypt (XMM1, UnwrappedKey) ;\n                XMM2 := AES256Decrypt (XMM2, UnwrappedKey) ;\n                XMM3 := AES256Decrypt (XMM3, UnwrappedKey) ;\n                XMM4 := AES256Decrypt (XMM4, UnwrappedKey) ;\n                XMM5 := AES256Decrypt (XMM5, UnwrappedKey) ;\n                XMM6 := AES256Decrypt (XMM6, UnwrappedKey) ;\n                XMM7 := AES256Decrypt (XMM7, UnwrappedKey) ;\n                RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<p>1. Further details on Key Locker and usage of this instruction can be found here:</p>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESDECWIDE256KLunsigned char _mm_aesdecwide256kl_u8(__m128i odata[8], const __m128i idata[8], const void* h);\n</pre>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>If CPUID.19H:EBX.WIDE_KL [bit 2] = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesdecwide256kl"},"/x86/aesenc":{"name":"AESENC","description":"Perform One Round of an AES Encryption Flow","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENC\n\t\t— Perform One Round of an AES Encryption Flow</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENC\n\t\t— Perform One Round of an AES Encryption Flow</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 DC /r AESENC xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.</td></tr>\n<tr>\n<td>VEX.128.66.0F38.WIG DC /r VAESENC xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AES AVX</td>\n<td>Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from the xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F38.WIG DC /r VAESENC ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>VAES</td>\n<td>Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.66.0F38.WIG DC /r VAESENC xmm1, xmm2, xmm3/m128</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from the xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F38.WIG DC /r VAESENC ymm1, ymm2, ymm3/m256</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform one round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from the ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F38.WIG DC /r VAESENC zmm1, zmm2, zmm3/m512</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512F</td>\n<td>Perform one round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from the zmm3/m512; store the result in zmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full Mem</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>This instruction performs a single round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.</p>\n<p>Use the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.</p>\n<p>VEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.</p>\n<p>The EVEX encoded form of this instruction does not support memory fault suppression.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aesenc\">AESENC<a class=\"anchor\" href=\"#aesenc\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>STATE := SRC1;\nRoundKey := SRC2;\nSTATE := ShiftRows( STATE );\nSTATE := SubBytes( STATE );\nSTATE := MixColumns( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaesenc--128b-and-256b-vex-encoded-versions-\">VAESENC (128b and 256b VEX Encoded Versions)<a class=\"anchor\" href=\"#vaesenc--128b-and-256b-vex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256)\nFOR I := 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    STATE := MixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaesenc--evex-encoded-version-\">VAESENC (EVEX Encoded Version)<a class=\"anchor\" href=\"#vaesenc--evex-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256), (4,512)\nFOR i := 0 to KL-1:\n    STATE := SRC1.xmm[i] // xmm[i] is the i’th xmm word in the SIMD register\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    STATE := MixColumns( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESENC __m128i _mm_aesenc (__m128i, __m128i)\n</pre>\n<pre>VAESENC __m256i _mm256_aesenc_epi128(__m256i, __m256i);\n</pre>\n<pre>VAESENC __m512i _mm512_aesenc_epi128(__m512i, __m512i);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded: See <span class=\"not-imported\">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesenc"},"/x86/aesenc128kl":{"name":"AESENC128KL","description":"Perform Ten Rounds of AES Encryption Flow With Key Locker Using 128-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENC128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker Using 128-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENC128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker Using 128-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 DC !(11):rrr:bbb AESENC128KL xmm, m384</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE</td>\n<td>Encrypt xmm using 128-bit AES key indicated by handle at m384 and store result in xmm.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESENC128KL<sup>1</sup> instruction performs ten rounds of AES to encrypt the first operand using the 128-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesenc128kl\">AESENC128KL<a class=\"anchor\" href=\"#aesenc128kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128\n                );\nIF (Illegal Handle) {\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF (Authentic == 0)\n        THEN RFLAGS.ZF := 1;\n        ELSE\n            DEST := AES128Encrypt (DEST, UnwrappedKey) ;\n            RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESENC128KL unsigned char _mm_aesenc128kl_u8(__m128i* odata, __m128i idata, const void* h);\n</pre>\n<pre>1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesenc128kl"},"/x86/aesenc256kl":{"name":"AESENC256KL","description":"Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENC256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENC256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker Using 256-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 DE !(11):rrr:bbb AESENC256KL xmm, m512</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE</td>\n<td>Encrypt xmm using 256-bit AES key indicated by handle at m512 and store result in xmm.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESENC256KL<sup>1</sup> instruction performs 14 rounds of AES to encrypt the first operand using the 256-bit key indicated by the handle from the second operand. It stores the result in the first operand if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesenc256kl\">AESENC256KL<a class=\"anchor\" href=\"#aesenc256kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    DEST := AES256Encrypt (DEST, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESENC256KL unsigned char _mm_aesenc256kl_u8(__m128i* odata, __m128i idata, const void* h);\n</pre>\n<pre>1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesenc256kl"},"/x86/aesenclast":{"name":"AESENCLAST","description":"Perform Last Round of an AES Encryption Flow","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENCLAST\n\t\t— Perform Last Round of an AES Encryption Flow</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENCLAST\n\t\t— Perform Last Round of an AES Encryption Flow</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 DD /r AESENCLAST xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.</td></tr>\n<tr>\n<td>VEX.128.66.0F38.WIG DD /r VAESENCLAST xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AES AVX</td>\n<td>Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F38.WIG DD /r VAESENCLAST ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>VAES</td>\n<td>Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.128.66.0F38.WIG DD /r VAESENCLAST xmm1, xmm2, xmm3/m128</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform the last round of an AES encryption flow, using one 128-bit data (state) from xmm2 with one 128-bit round key from xmm3/m128; store the result in xmm1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F38.WIG DD /r VAESENCLAST ymm1, ymm2, ymm3/m256</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512VL</td>\n<td>Perform the last round of an AES encryption flow, using two 128-bit data (state) from ymm2 with two 128-bit round keys from ymm3/m256; store the result in ymm1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F38.WIG DD /r VAESENCLAST zmm1, zmm2, zmm3/m512</td>\n<td>C</td>\n<td>V/V</td>\n<td>VAES AVX512F</td>\n<td>Perform the last round of an AES encryption flow, using four 128-bit data (state) from zmm2 with four 128-bit round keys from zmm3/m512; store the result in zmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full Mem</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>This instruction performs the last round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.</p>\n<p>VEX and EVEX encoded versions of the instruction allows 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.</p>\n<p>The EVEX encoded form of this instruction does not support memory fault suppression.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aesenclast\">AESENCLAST<a class=\"anchor\" href=\"#aesenclast\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>STATE := SRC1;\nRoundKey := SRC2;\nSTATE := ShiftRows( STATE );\nSTATE := SubBytes( STATE );\nDEST[127:0] := STATE XOR RoundKey;\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaesenclast--128b-and-256b-vex-encoded-versions-\">VAESENCLAST (128b and 256b VEX Encoded Versions)<a class=\"anchor\" href=\"#vaesenclast--128b-and-256b-vex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (1,128), (2,256)\nFOR I=0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vaesenclast--evex-encoded-version-\">VAESENCLAST (EVEX Encoded Version)<a class=\"anchor\" href=\"#vaesenclast--evex-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL,VL) = (1,128), (2,256), (4,512)\nFOR i = 0 to KL-1:\n    STATE := SRC1.xmm[i]\n    RoundKey := SRC2.xmm[i]\n    STATE := ShiftRows( STATE )\n    STATE := SubBytes( STATE )\n    DEST.xmm[i] := STATE XOR RoundKey\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESENCLAST __m128i _mm_aesenclast (__m128i, __m128i)\n</pre>\n<pre>VAESENCLAST __m256i _mm256_aesenclast_epi128(__m256i, __m256i);\n</pre>\n<pre>VAESENCLAST __m512i _mm512_aesenclast_epi128(__m512i, __m512i);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded: See <span class=\"not-imported\">Table 2-50</span>, “Type E4NF Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesenclast"},"/x86/aesencwide128kl":{"name":"AESENCWIDE128KL","description":"Perform Ten Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENCWIDE128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENCWIDE128KL\n\t\t— Perform Ten Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 128-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 D8 !(11):000:bbb AESENCWIDE128KL m384, &lt;XMM0-7&gt;</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE WIDE_KL</td>\n<td>Encrypt XMM0-7 using 128-bit AES key indicated by handle at m384 and store each resultant block back to its corresponding register.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operands 2—9</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:r/m (r)</td>\n<td>Implicit XMM0-7 (r, w)</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESENCWIDE128KL<sup>1</sup> instruction performs ten rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 128-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesencwide128kl\">AESENCWIDE128KL<a class=\"anchor\" href=\"#aesencwide128kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 384 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES128\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey);\n        IF Authentic == 0\n            THEN RFLAGS.ZF := 1;\n            ELSE\n            XMM0 := AES128Encrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES128Encrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES128Encrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES128Encrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES128Encrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES128Encrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES128Encrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES128Encrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESENCWIDE128KLunsigned char _mm_aesencwide128kl_u8(__m128i odata[8], const __m128i idata[8], const void* h);\n</pre>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.AESKLE = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>If CPUID.19H:EBX.WIDE_KL [bit 2] = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesencwide128kl"},"/x86/aesencwide256kl":{"name":"AESENCWIDE256KL","description":"Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESENCWIDE256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESENCWIDE256KL\n\t\t— Perform 14 Rounds of AES Encryption Flow With Key Locker on 8 BlocksUsing 256-Bit Key</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 38 D8 !(11):010:bbb AESENCWIDE256KL m512, &lt;XMM0-7&gt;</td>\n<td>A</td>\n<td>V/V</td>\n<td>AESKLE WIDE_KL</td>\n<td>Encrypt XMM0-7 using 256-bit AES key indicated by handle at m512 and store each resultant block back to its corresponding register.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple</th>\n<th>Operand 1</th>\n<th>Operands 2—9</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:r/m (r)</td>\n<td>Implicit XMM0-7 (r, w)</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The AESENCWIDE256KL<sup>1</sup> instruction performs 14 rounds of AES to encrypt each of the eight blocks in XMM0-7 using the 256-bit key indicated by the handle from the second operand. It replaces each input block in XMM0-7 with its corresponding encrypted block if the operation succeeds (e.g., does not run into a handle violation failure).</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h4 id=\"aesencwide256kl\">AESENCWIDE256KL<a class=\"anchor\" href=\"#aesencwide256kl\">\n\t\t\t¶\n\t\t</a></h4>\n<pre>Handle := UnalignedLoad of 512 bit (SRC); // Load is not guaranteed to be atomic.\nIllegal Handle = (\n                HandleReservedBitSet (Handle) ||\n                (Handle[0] AND (CPL &gt; 0)) ||\n                Handle [1] ||\n                HandleKeyType (Handle) != HANDLE_KEY_TYPE_AES256\n                );\nIF (Illegal Handle)\n    THEN RFLAGS.ZF := 1;\n    ELSE\n        (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey);\n        IF (Authentic == 0)\n            THEN RFLAGS.ZF := 1;\n            ELSE\n                    XMM0 := AES256Encrypt (XMM0, UnwrappedKey) ;\n                    XMM1 := AES256Encrypt (XMM1, UnwrappedKey) ;\n                    XMM2 := AES256Encrypt (XMM2, UnwrappedKey) ;\n                    XMM3 := AES256Encrypt (XMM3, UnwrappedKey) ;\n                    XMM4 := AES256Encrypt (XMM4, UnwrappedKey) ;\n                    XMM5 := AES256Encrypt (XMM5, UnwrappedKey) ;\n                    XMM6 := AES256Encrypt (XMM6, UnwrappedKey) ;\n                    XMM7 := AES256Encrypt (XMM7, UnwrappedKey) ;\n                    RFLAGS.ZF := 0;\n        FI;\nFI;\nRFLAGS.OF, SF, AF, PF, CF := 0;\n1. Further details on Key Locker and usage of this instruction can be found here:\n</pre>\n<h3 id=\"https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html.<a class=\"anchor\" href=\"#https---software-intel-com-content-www-us-en-develop-download-intel-key-locker-specification-html-\">\n\t\t\t¶\n\t\t</a></h3>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is set to 0 if the operation succeeded and set to 1 if the operation failed due to a handle violation. The other arithmetic flags (OF, SF, AF, PF, CF) are cleared to 0.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>AESENCWIDE256KLunsigned char _mm_aesencwide256kl_u8(__m128i odata[8], const __m128i idata[8], const void* h);\n</pre>\n<h2 id=\"exceptions--all-operating-modes-\">Exceptions (All Operating Modes)<a class=\"anchor\" href=\"#exceptions--all-operating-modes-\">\n\t\t\t¶\n\t\t</a></h2>\n<p>#UD If the LOCK prefix is used.</p>\n<p>If CPUID.07H:ECX.KL [bit 23] = 0.</p>\n<p>If CR4.KL = 0.</p>\n<p>If CPUID.19H:EBX.AESKLE [bit 0] = 0.</p>\n<p>If CR0.EM = 1.</p>\n<p>If CR4.OSFXSR = 0.</p>\n<p>If CPUID.19H:EBX.WIDE_KL [bit 2] = 0.</p>\n<p>#NM If CR0.TS = 1.</p>\n<p>#PF If a page fault occurs.</p>\n<p>#GP(0) If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</p>\n<p>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</p>\n<p>If the memory address is in a non-canonical form.</p>\n<p>#SS(0) If a memory operand effective address is outside the SS segment limit.</p>\n<p>If a memory address referencing the SS segment is in a non-canonical form.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesencwide256kl"},"/x86/aesimc":{"name":"AESIMC","description":"Perform the AES InvMixColumn Transformation","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESIMC\n\t\t— Perform the AES InvMixColumn Transformation</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESIMC\n\t\t— Perform the AES InvMixColumn Transformation</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 DB /r AESIMC xmm1, xmm2/m128</td>\n<td>RM</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F38.WIG DB /r VAESIMC xmm1, xmm2/m128</td>\n<td>RM</td>\n<td>V/V</td>\n<td>Both AES and AVX flags</td>\n<td>Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Perform the InvMixColumns transformation on the source operand and store the result in the destination operand. The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.</p>\n<p>Note: the AESIMC instruction should be applied to the expanded AES round keys (except for the first and last round key) in order to prepare them for decryption using the “Equivalent Inverse Cipher” (defined in FIPS 197).</p>\n<p>128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p>\n<p>VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.</p>\n<p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aesimc\">AESIMC<a class=\"anchor\" href=\"#aesimc\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[127:0] := InvMixColumns( SRC );\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaesimc\">VAESIMC<a class=\"anchor\" href=\"#vaesimc\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[127:0] := InvMixColumns( SRC );\nDEST[MAXVL-1:128] := 0;\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESIMC __m128i _mm_aesimc (__m128i)\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions,” additionally:</p>\n<table>\n<tr>\n<td>#UD</td>\n<td>If VEX.vvvv ≠ 1111B.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aesimc"},"/x86/aeskeygenassist":{"name":"AESKEYGENASSIST","description":"AES Round Key Generation Assist","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AESKEYGENASSIST\n\t\t— AES Round Key Generation Assist</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AESKEYGENASSIST\n\t\t— AES Round Key Generation Assist</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 3A DF /r ib AESKEYGENASSIST xmm1, xmm2/m128, imm8</td>\n<td>RMI</td>\n<td>V/V</td>\n<td>AES</td>\n<td>Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F3A.WIG DF /r ib VAESKEYGENASSIST xmm1, xmm2/m128, imm8</td>\n<td>RMI</td>\n<td>V/V</td>\n<td>Both AES and AVX flags</td>\n<td>Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RMI</td>\n<td>ModRM:reg (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Assist in expanding the AES cipher key, by computing steps towards generating a round key for encryption, using 128-bit data specified in the source operand and an 8-bit round constant specified as an immediate, store the result in the destination operand.</p>\n<p>The destination operand is an XMM register. The source operand can be an XMM register or a 128-bit memory location.</p>\n<p>128-bit Legacy SSE version: Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged.</p>\n<p>VEX.128 encoded version: Bits (MAXVL-1:128) of the destination YMM register are zeroed.</p>\n<p>Note: In VEX-encoded versions, VEX.vvvv is reserved and must be 1111b, otherwise instructions will #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"aeskeygenassist\">AESKEYGENASSIST<a class=\"anchor\" href=\"#aeskeygenassist\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>X3[31:0] := SRC [127: 96];\nX2[31:0] := SRC [95: 64];\nX1[31:0] := SRC [63: 32];\nX0[31:0] := SRC [31: 0];\nRCON[31:0] := ZeroExtend(imm8[7:0]);\nDEST[31:0] := SubWord(X1);\nDEST[63:32 ] := RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] := SubWord(X3);\nDEST[127:96] := RotWord( SubWord(X3) ) XOR RCON;\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vaeskeygenassist\">VAESKEYGENASSIST<a class=\"anchor\" href=\"#vaeskeygenassist\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>X3[31:0] := SRC [127: 96];\nX2[31:0] := SRC [95: 64];\nX1[31:0] := SRC [63: 32];\nX0[31:0] := SRC [31: 0];\nRCON[31:0] := ZeroExtend(imm8[7:0]);\nDEST[31:0] := SubWord(X1);\nDEST[63:32 ] := RotWord( SubWord(X1) ) XOR RCON;\nDEST[95:64] := SubWord(X3);\nDEST[127:96] := RotWord( SubWord(X3) ) XOR RCON;\nDEST[MAXVL-1:128] := 0;\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>(V)AESKEYGENASSIST __m128i _mm_aeskeygenassist (__m128i, const int)\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions,” additionally:</p>\n<table>\n<tr>\n<td>#UD</td>\n<td>If VEX.vvvv ≠ 1111B.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/aeskeygenassist"},"/x86/and":{"name":"AND","description":"Logical AND","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>AND\n\t\t— Logical AND</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>AND\n\t\t— Logical AND</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>24 ib</td>\n<td>AND AL, imm8</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>AL AND imm8.</td></tr>\n<tr>\n<td>25 iw</td>\n<td>AND AX, imm16</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>AX AND imm16.</td></tr>\n<tr>\n<td>25 id</td>\n<td>AND EAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>EAX AND imm32.</td></tr>\n<tr>\n<td>REX.W + 25 id</td>\n<td>AND RAX, imm32</td>\n<td>I</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>RAX AND imm32 sign-extended to 64-bits.</td></tr>\n<tr>\n<td>80 /4 ib</td>\n<td>AND r/m8, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m8 AND imm8.</td></tr>\n<tr>\n<td>REX + 80 /4 ib</td>\n<td>AND r/m8<sup>*</sup>, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m8 AND imm8.</td></tr>\n<tr>\n<td>81 /4 iw</td>\n<td>AND r/m16, imm16</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m16 AND imm16.</td></tr>\n<tr>\n<td>81 /4 id</td>\n<td>AND r/m32, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m32 AND imm32.</td></tr>\n<tr>\n<td>REX.W + 81 /4 id</td>\n<td>AND r/m64, imm32</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m64 AND imm32 sign extended to 64-bits.</td></tr>\n<tr>\n<td>83 /4 ib</td>\n<td>AND r/m16, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m16 AND imm8 (sign-extended).</td></tr>\n<tr>\n<td>83 /4 ib</td>\n<td>AND r/m32, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m32 AND imm8 (sign-extended).</td></tr>\n<tr>\n<td>REX.W + 83 /4 ib</td>\n<td>AND r/m64, imm8</td>\n<td>MI</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m64 AND imm8 (sign-extended).</td></tr>\n<tr>\n<td>20 /r</td>\n<td>AND r/m8, r8</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m8 AND r8.</td></tr>\n<tr>\n<td>REX + 20 /r</td>\n<td>AND r/m8<sup>*</sup>, r8<sup>*</sup></td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m64 AND r8 (sign-extended).</td></tr>\n<tr>\n<td>21 /r</td>\n<td>AND r/m16, r16</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m16 AND r16.</td></tr>\n<tr>\n<td>21 /r</td>\n<td>AND r/m32, r32</td>\n<td>MR</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r/m32 AND r32.</td></tr>\n<tr>\n<td>REX.W + 21 /r</td>\n<td>AND r/m64, r64</td>\n<td>MR</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m64 AND r32.</td></tr>\n<tr>\n<td>22 /r</td>\n<td>AND r8, r/m8</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r8 AND r/m8.</td></tr>\n<tr>\n<td>REX + 22 /r</td>\n<td>AND r8<sup>*</sup>, r/m8<sup>*</sup></td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r/m64 AND r8 (sign-extended).</td></tr>\n<tr>\n<td>23 /r</td>\n<td>AND r16, r/m16</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r16 AND r/m16.</td></tr>\n<tr>\n<td>23 /r</td>\n<td>AND r32, r/m32</td>\n<td>RM</td>\n<td>Valid</td>\n<td>Valid</td>\n<td>r32 AND r/m32.</td></tr>\n<tr>\n<td>REX.W + 23 /r</td>\n<td>AND r64, r/m64</td>\n<td>RM</td>\n<td>Valid</td>\n<td>N.E.</td>\n<td>r64 AND r/m64.</td></tr></table>\n<blockquote>\n<p>*In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.</p></blockquote>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MR</td>\n<td>ModRM:r/m (r, w)</td>\n<td>ModRM:reg (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>MI</td>\n<td>ModRM:r/m (r, w)</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>I</td>\n<td>AL/AX/EAX/RAX</td>\n<td>imm8/16/32</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise AND operation on the destination (first) and source (second) operands and stores the result in the destination operand location. The source operand can be an immediate, a register, or a memory location; the destination operand can be a register or a memory location. (However, two memory operands cannot be used in one instruction.) Each bit of the result is set to 1 if both corresponding bits of the first and second operands are 1; otherwise, it is set to 0.</p>\n<p>This instruction can be used with a LOCK prefix to allow the it to be executed atomically.</p>\n<p>In 64-bit mode, the instruction’s default operation size is 32 bits. Using a REX prefix in the form of REX.R permits access to additional registers (R8-R15). Using a REX prefix in the form of REX.W promotes operation to 64 bits. See the summary chart at the beginning of this section for encoding data and limits.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>DEST := DEST AND SRC;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The OF and CF flags are cleared; the SF, ZF, and PF flags are set according to the result. The state of the AF flag is undefined.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"3\">#GP(0)</td>\n<td>If the destination operand points to a non-writable segment.</td></tr>\n<tr>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register contains a NULL segment selector.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#GP(0)</td>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used but the destination is not a memory operand.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/and"},"/x86/andn":{"name":"ANDN","description":"Logical AND NOT","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ANDN\n\t\t— Logical AND NOT</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ANDN\n\t\t— Logical AND NOT</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>VEX.LZ.0F38.W0 F2 /r ANDN r32a, r32b, r/m32</td>\n<td>RVM</td>\n<td>V/V</td>\n<td>BMI1</td>\n<td>Bitwise AND of inverted r32b with r/m32, store result in r32a.</td></tr>\n<tr>\n<td>VEX.LZ. 0F38.W1 F2 /r ANDN r64a, r64b, r/m64</td>\n<td>RVM</td>\n<td>V/NE</td>\n<td>BMI1</td>\n<td>Bitwise AND of inverted r64b with r/m64, store result in r64a.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RVM</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise logical AND of inverted second operand (the first source operand) with the third operand (the</p>\n<p>second source operand). The result is stored in the first operand (destination operand).</p>\n<p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>DEST := (NOT SRC1) bitwiseAND SRC2;\nSF := DEST[OperandSize -1];\nZF := (DEST = 0);\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>SF and ZF are updated based on result. OF and CF flags are cleared. AF and PF flags are undefined.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>Auto-generated from high-level language.\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-29</span>, “Type 13 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/andn"},"/x86/andnpd":{"name":"ANDNPD","description":"Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ANDNPD\n\t\t— Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ANDNPD\n\t\t— Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 55 /r ANDNPD xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE2</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in xmm1 and xmm2/mem.</td></tr>\n<tr>\n<td>VEX.128.66.0F 55 /r VANDNPD xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in xmm2 and xmm3/mem.</td></tr>\n<tr>\n<td>VEX.256.66.0F 55/r VANDNPD ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in ymm2 and ymm3/mem.</td></tr>\n<tr>\n<td>EVEX.128.66.0F.W1 55 /r VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F.W1 55 /r VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F.W1 55 /r VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512DQ</td>\n<td>Return the bitwise logical AND NOT of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise logical AND NOT of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vandnpd--evex-encoded-versions-\">VANDNPD (EVEX Encoded Versions)<a class=\"anchor\" href=\"#vandnpd--evex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := (NOT(SRC1[i+63:i])) BITWISE AND SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := (NOT(SRC1[i+63:i])) BITWISE AND SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vandnpd--vex-256-encoded-version-\">VANDNPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vandnpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] := (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[191:128] := (NOT(SRC1[191:128])) BITWISE AND SRC2[191:128]\nDEST[255:192] := (NOT(SRC1[255:192])) BITWISE AND SRC2[255:192]\nDEST[MAXVL-1:256] := 0\n</pre>\n<h3 id=\"vandnpd--vex-128-encoded-version-\">VANDNPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vandnpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := (NOT(SRC1[63:0])) BITWISE AND SRC2[63:0]\nDEST[127:64] := (NOT(SRC1[127:64])) BITWISE AND SRC2[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"andnpd--128-bit-legacy-sse-version-\">ANDNPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#andnpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := (NOT(DEST[63:0])) BITWISE AND SRC[63:0]\nDEST[127:64] := (NOT(DEST[127:64])) BITWISE AND SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VANDNPD __m512d _mm512_andnot_pd (__m512d a, __m512d b);\n</pre>\n<pre>VANDNPD __m512d _mm512_mask_andnot_pd (__m512d s, __mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VANDNPD __m512d _mm512_maskz_andnot_pd (__mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VANDNPD __m256d _mm256_mask_andnot_pd (__m256d s, __mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VANDNPD __m256d _mm256_maskz_andnot_pd (__mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VANDNPD __m128d _mm_mask_andnot_pd (__m128d s, __mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VANDNPD __m128d _mm_maskz_andnot_pd (__mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VANDNPD __m256d _mm256_andnot_pd (__m256d a, __m256d b);\n</pre>\n<pre>ANDNPD __m128d _mm_andnot_pd (__m128d a, __m128d b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-49</span>, “Type E4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/andnpd"},"/x86/andnps":{"name":"ANDNPS","description":"Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ANDNPS\n\t\t— Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ANDNPS\n\t\t— Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>NP 0F 55 /r ANDNPS xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE</td>\n<td>Return the bitwise logical AND NOT of packed single precision floating-point values in xmm1 and xmm2/mem.</td></tr>\n<tr>\n<td>VEX.128.0F 55 /r VANDNPS xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND NOT of packed single precision floating-point values in xmm2 and xmm3/mem.</td></tr>\n<tr>\n<td>VEX.256.0F 55 /r VANDNPS ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND NOT of packed single precision floating-point values in ymm2 and ymm3/mem.</td></tr>\n<tr>\n<td>EVEX.128.0F.W0 55 /r VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.0F.W0 55 /r VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.0F.W0 55 /r VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise logical AND NOT of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vandnps--evex-encoded-versions-\">VANDNPS (EVEX Encoded Versions)<a class=\"anchor\" href=\"#vandnps--evex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+31:i] := (NOT(SRC1[i+31:i])) BITWISE AND SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := (NOT(SRC1[i+31:i])) BITWISE AND SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vandnps--vex-256-encoded-version-\">VANDNPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vandnps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] := (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] := (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] := (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[159:128] := (NOT(SRC1[159:128])) BITWISE AND SRC2[159:128]\nDEST[191:160] := (NOT(SRC1[191:160])) BITWISE AND SRC2[191:160]\nDEST[223:192] := (NOT(SRC1[223:192])) BITWISE AND SRC2[223:192]\nDEST[255:224] := (NOT(SRC1[255:224])) BITWISE AND SRC2[255:224].\nDEST[MAXVL-1:256] := 0\n</pre>\n<h3 id=\"vandnps--vex-128-encoded-version-\">VANDNPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vandnps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := (NOT(SRC1[31:0])) BITWISE AND SRC2[31:0]\nDEST[63:32] := (NOT(SRC1[63:32])) BITWISE AND SRC2[63:32]\nDEST[95:64] := (NOT(SRC1[95:64])) BITWISE AND SRC2[95:64]\nDEST[127:96] := (NOT(SRC1[127:96])) BITWISE AND SRC2[127:96]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"andnps--128-bit-legacy-sse-version-\">ANDNPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#andnps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := (NOT(DEST[31:0])) BITWISE AND SRC[31:0]\nDEST[63:32] := (NOT(DEST[63:32])) BITWISE AND SRC[63:32]\nDEST[95:64] := (NOT(DEST[95:64])) BITWISE AND SRC[95:64]\nDEST[127:96] := (NOT(DEST[127:96])) BITWISE AND SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VANDNPS __m512 _mm512_andnot_ps (__m512 a, __m512 b);\n</pre>\n<pre>VANDNPS __m512 _mm512_mask_andnot_ps (__m512 s, __mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VANDNPS __m512 _mm512_maskz_andnot_ps (__mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VANDNPS __m256 _mm256_mask_andnot_ps (__m256 s, __mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VANDNPS __m256 _mm256_maskz_andnot_ps (__mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VANDNPS __m128 _mm_mask_andnot_ps (__m128 s, __mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VANDNPS __m128 _mm_maskz_andnot_ps (__mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VANDNPS __m256 _mm256_andnot_ps (__m256 a, __m256 b);\n</pre>\n<pre>ANDNPS __m128 _mm_andnot_ps (__m128 a, __m128 b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-49</span>, “Type E4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/andnps"},"/x86/andpd":{"name":"ANDPD","description":"Bitwise Logical AND of Packed Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ANDPD\n\t\t— Bitwise Logical AND of Packed Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ANDPD\n\t\t— Bitwise Logical AND of Packed Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 54 /r ANDPD xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE2</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in xmm1 and xmm2/mem.</td></tr>\n<tr>\n<td>VEX.128.66.0F 54 /r VANDPD xmm1, xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in xmm2 and xmm3/mem.</td></tr>\n<tr>\n<td>VEX.256.66.0F 54 /r VANDPD ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in ymm2 and ymm3/mem.</td></tr>\n<tr>\n<td>EVEX.128.66.0F.W1 54 /r VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.66.0F.W1 54 /r VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.66.0F.W1 54 /r VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512DQ</td>\n<td>Return the bitwise logical AND of packed double precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise logical AND of the two, four or eight packed double precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 64-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vandpd--evex-encoded-versions-\">VANDPD (EVEX Encoded Versions)<a class=\"anchor\" href=\"#vandpd--evex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (2, 128), (4, 256), (8, 512)\nFOR j := 0 TO KL-1\n    i := j * 64\n    IF k1[j] OR *no writemask*\n        THEN\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[63:0]\n                ELSE\n                    DEST[i+63:i] := SRC1[i+63:i] BITWISE AND SRC2[i+63:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+63:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+63:i] = 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0\n</pre>\n<h3 id=\"vandpd--vex-256-encoded-version-\">VANDPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vandpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[191:128] := SRC1[191:128] BITWISE AND SRC2[191:128]\nDEST[255:192] := SRC1[255:192] BITWISE AND SRC2[255:192]\nDEST[MAXVL-1:256] := 0\n</pre>\n<h3 id=\"vandpd--vex-128-encoded-version-\">VANDPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vandpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := SRC1[63:0] BITWISE AND SRC2[63:0]\nDEST[127:64] := SRC1[127:64] BITWISE AND SRC2[127:64]\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"andpd--128-bit-legacy-sse-version-\">ANDPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#andpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[63:0] := DEST[63:0] BITWISE AND SRC[63:0]\nDEST[127:64] := DEST[127:64] BITWISE AND SRC[127:64]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VANDPD __m512d _mm512_and_pd (__m512d a, __m512d b);\n</pre>\n<pre>VANDPD __m512d _mm512_mask_and_pd (__m512d s, __mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VANDPD __m512d _mm512_maskz_and_pd (__mmask8 k, __m512d a, __m512d b);\n</pre>\n<pre>VANDPD __m256d _mm256_mask_and_pd (__m256d s, __mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VANDPD __m256d _mm256_maskz_and_pd (__mmask8 k, __m256d a, __m256d b);\n</pre>\n<pre>VANDPD __m128d _mm_mask_and_pd (__m128d s, __mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VANDPD __m128d _mm_maskz_and_pd (__mmask8 k, __m128d a, __m128d b);\n</pre>\n<pre>VANDPD __m256d _mm256_and_pd (__m256d a, __m256d b);\n</pre>\n<pre>ANDPD __m128d _mm_and_pd (__m128d a, __m128d b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-49</span>, “Type E4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/andpd"},"/x86/andps":{"name":"ANDPS","description":"Bitwise Logical AND of Packed Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ANDPS\n\t\t— Bitwise Logical AND of Packed Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ANDPS\n\t\t— Bitwise Logical AND of Packed Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op / En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>NP 0F 54 /r ANDPS xmm1, xmm2/m128</td>\n<td>A</td>\n<td>V/V</td>\n<td>SSE</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in xmm1 and xmm2/mem.</td></tr>\n<tr>\n<td>VEX.128.0F 54 /r VANDPS xmm1,xmm2, xmm3/m128</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/mem.</td></tr>\n<tr>\n<td>VEX.256.0F 54 /r VANDPS ymm1, ymm2, ymm3/m256</td>\n<td>B</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/mem.</td></tr>\n<tr>\n<td>EVEX.128.0F.W0 54 /r VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.256.0F.W0 54 /r VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512VL AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1.</td></tr>\n<tr>\n<td>EVEX.512.0F.W0 54 /r VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst</td>\n<td>C</td>\n<td>V/V</td>\n<td>AVX512DQ</td>\n<td>Return the bitwise logical AND of packed single precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Tuple Type</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>A</td>\n<td>N/A</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr>\n<tr>\n<td>B</td>\n<td>N/A</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr>\n<tr>\n<td>C</td>\n<td>Full</td>\n<td>ModRM:reg (w)</td>\n<td>EVEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Performs a bitwise logical AND of the four, eight or sixteen packed single precision floating-point values from the first source operand and the second source operand, and stores the result in the destination operand.</p>\n<p>EVEX encoded versions: The first source operand is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register, a 512/256/128-bit memory location, or a 512/256/128-bit vector broadcasted from a 32-bit memory location. The destination operand is a ZMM/YMM/XMM register conditionally updated with writemask k1.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand is a YMM register or a 256-bit memory location. The destination operand is a YMM register. The upper bits (MAXVL-1:256) of the corresponding ZMM register destination are zeroed.</p>\n<p>VEX.128 encoded version: The first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding ZMM register destination are zeroed.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding ZMM register destination are unmodified.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"vandps--evex-encoded-versions-\">VANDPS (EVEX Encoded Versions)<a class=\"anchor\" href=\"#vandps--evex-encoded-versions-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>(KL, VL) = (4, 128), (8, 256), (16, 512)\nFOR j := 0 TO KL-1\n    i := j * 32\n    IF k1[j] OR *no writemask*\n            IF (EVEX.b == 1) AND (SRC2 *is memory*)\n                THEN\n                    DEST[i+63:i] := SRC1[i+31:i] BITWISE AND SRC2[31:0]\n                ELSE\n                    DEST[i+31:i] := SRC1[i+31:i] BITWISE AND SRC2[i+31:i]\n            FI;\n        ELSE\n            IF *merging-masking* ; merging-masking\n                THEN *DEST[i+31:i] remains unchanged*\n                ELSE ; zeroing-masking\n                    DEST[i+31:i] := 0\n            FI;\n    FI;\nENDFOR\nDEST[MAXVL-1:VL] := 0;\n</pre>\n<h3 id=\"vandps--vex-256-encoded-version-\">VANDPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vandps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[159:128] := SRC1[159:128] BITWISE AND SRC2[159:128]\nDEST[191:160] := SRC1[191:160] BITWISE AND SRC2[191:160]\nDEST[223:192] := SRC1[223:192] BITWISE AND SRC2[223:192]\nDEST[255:224] := SRC1[255:224] BITWISE AND SRC2[255:224].\nDEST[MAXVL-1:256] := 0;\n</pre>\n<h3 id=\"vandps--vex-128-encoded-version-\">VANDPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vandps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := SRC1[31:0] BITWISE AND SRC2[31:0]\nDEST[63:32] := SRC1[63:32] BITWISE AND SRC2[63:32]\nDEST[95:64] := SRC1[95:64] BITWISE AND SRC2[95:64]\nDEST[127:96] := SRC1[127:96] BITWISE AND SRC2[127:96]\nDEST[MAXVL-1:128] := 0;\n</pre>\n<h3 id=\"andps--128-bit-legacy-sse-version-\">ANDPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#andps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>DEST[31:0] := DEST[31:0] BITWISE AND SRC[31:0]\nDEST[63:32] := DEST[63:32] BITWISE AND SRC[63:32]\nDEST[95:64] := DEST[95:64] BITWISE AND SRC[95:64]\nDEST[127:96] := DEST[127:96] BITWISE AND SRC[127:96]\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>VANDPS __m512 _mm512_and_ps (__m512 a, __m512 b);\n</pre>\n<pre>VANDPS __m512 _mm512_mask_and_ps (__m512 s, __mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VANDPS __m512 _mm512_maskz_and_ps (__mmask16 k, __m512 a, __m512 b);\n</pre>\n<pre>VANDPS __m256 _mm256_mask_and_ps (__m256 s, __mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VANDPS __m256 _mm256_maskz_and_ps (__mmask8 k, __m256 a, __m256 b);\n</pre>\n<pre>VANDPS __m128 _mm_mask_and_ps (__m128 s, __mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VANDPS __m128 _mm_maskz_and_ps (__mmask8 k, __m128 a, __m128 b);\n</pre>\n<pre>VANDPS __m256 _mm256_and_ps (__m256 a, __m256 b);\n</pre>\n<pre>ANDPS __m128 _mm_and_ps (__m128 a, __m128 b);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>VEX-encoded instruction, see <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p>\n<p>EVEX-encoded instruction, see <span class=\"not-imported\">Table 2-49</span>, “Type E4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/andps"},"/x86/arpl":{"name":"ARPL","description":"Adjust RPL Field of Segment Selector","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>ARPL\n\t\t— Adjust RPL Field of Segment Selector</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>ARPL\n\t\t— Adjust RPL Field of Segment Selector</h1>\n\n<table>\n<tr>\n<th>Opcode</th>\n<th>Instruction</th>\n<th>Op/En</th>\n<th>64-bit Mode</th>\n<th>Compat/Leg Mode</th>\n<th>Description</th></tr>\n<tr>\n<td>63 /r</td>\n<td>ARPL r/m16, r16</td>\n<td>MR</td>\n<td>N. E.</td>\n<td>Valid</td>\n<td>Adjust RPL of r/m16 to not less than RPL of r16.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>MR</td>\n<td>ModRM:r/m (w)</td>\n<td>ModRM:reg (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Compares the RPL fields of two segment selectors. The first operand (the destination operand) contains one segment selector and the second operand (source operand) contains the other. (The RPL field is located in bits 0 and 1 of each operand.) If the RPL field of the destination operand is less than the RPL field of the source operand, the ZF flag is set and the RPL field of the destination operand is increased to match that of the source operand. Otherwise, the ZF flag is cleared and no change is made to the destination operand. (The destination operand can be a word register or a memory location; the source operand must be a word register.)</p>\n<p>The ARPL instruction is provided for use by operating-system procedures (however, it can also be used by applications). It is generally used to adjust the RPL of a segment selector that has been passed to the operating system by an application program to match the privilege level of the application program. Here the segment selector passed to the operating system is placed in the destination operand and segment selector for the application program’s code segment is placed in the source operand. (The RPL field in the source operand represents the privilege level of the application program.) Execution of the ARPL instruction then ensures that the RPL of the segment selector received by the operating system is no lower (does not have a higher privilege) than the privilege level of the application program (the segment selector for the application program’s code segment can be read from the stack following a procedure call).</p>\n<p>This instruction executes as described in compatibility mode and legacy mode. It is not encodable in 64-bit mode.</p>\n<p>See “Checking Caller Access Privileges” in Chapter 3, “Protected-Mode Memory Management,” of the Intel<em><sup>® </sup></em>64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for more information about the use of this instruction.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>IF 64-BIT MODE\n    THEN\n        See MOVSXD;\n    ELSE\n        IF DEST[RPL] &lt; SRC[RPL]\n            THEN\n                ZF := 1;\n                DEST[RPL] := SRC[RPL];\n            ELSE\n                ZF := 0;\n        FI;\nFI;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>The ZF flag is set to 1 if the RPL field of the destination operand is less than that of the source operand; otherwise, it is set to 0.</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"3\">#GP(0)</td>\n<td>If the destination is located in a non-writable segment.</td></tr>\n<tr>\n<td>If a memory operand effective address is outside the CS, DS, ES, FS, or GS segment limit.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a NULL segment selector.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory operand effective address is outside the SS segment limit.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>If a page fault occurs.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr>\n<tr>\n<td>#UD</td>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>The ARPL instruction is not recognized in real-address mode.</td></tr>\n<tr>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td rowspan=\"2\">#UD</td>\n<td>The ARPL instruction is not recognized in virtual-8086 mode.</td></tr>\n<tr>\n<td>If the LOCK prefix is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Not applicable.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/arpl"},"/x86/bextr":{"name":"BEXTR","description":"Bit Field Extract","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BEXTR\n\t\t— Bit Field Extract</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BEXTR\n\t\t— Bit Field Extract</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>VEX.LZ.0F38.W0 F7 /r BEXTR r32a, r/m32, r32b</td>\n<td>RMV</td>\n<td>V/V</td>\n<td>BMI1</td>\n<td>Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a.</td></tr>\n<tr>\n<td>VEX.LZ.0F38.W1 F7 /r BEXTR r64a, r/m64, r64b</td>\n<td>RMV</td>\n<td>V/N.E.</td>\n<td>BMI1</td>\n<td>Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RMV</td>\n<td>ModRM:reg (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>VEX.vvvv (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Extracts contiguous bits from the first source operand (the second operand) using an index value and length value specified in the second source operand (the third operand). Bit 7:0 of the second source operand specifies the starting bit position of bit extraction. A START value exceeding the operand size will not extract any bits from the second source operand. Bit 15:8 of the second source operand specifies the maximum number of bits (LENGTH) beginning at the START position to extract. Only bit positions up to (OperandSize -1) of the first source operand are extracted. The extracted bits are written to the destination register, starting from the least significant bit. All higher order bits in the destination operand (starting at bit position LENGTH) are zeroed. The destination register is cleared if no bits are extracted.</p>\n<p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>START := SRC2[7:0];\nLEN := SRC2[15:8];\nTEMP := ZERO_EXTEND_TO_512 (SRC1 );\nDEST := ZERO_EXTEND(TEMP[START+LEN -1: START]);\nZF := (DEST = 0);\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF is updated based on the result. AF, SF, and PF are undefined. All other flags are cleared.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BEXTR unsigned __int32 _bextr_u32(unsigned __int32 src, unsigned __int32 start. unsigned __int32 len);\n</pre>\n<pre>BEXTR unsigned __int64 _bextr_u64(unsigned __int64 src, unsigned __int32 start. unsigned __int32 len);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-29</span>, “Type 13 Class Exception Conditions,” additionally:</p>\n<table>\n<tr>\n<td>#UD</td>\n<td>If VEX.W = 1.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/bextr"},"/x86/blendpd":{"name":"BLENDPD","description":"Blend Packed Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLENDPD\n\t\t— Blend Packed Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLENDPD\n\t\t— Blend Packed Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 3A 0D /r ib BLENDPD xmm1, xmm2/m128, imm8</td>\n<td>RMI</td>\n<td>V/V</td>\n<td>SSE4_1</td>\n<td>Select packed double precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F3A.WIG 0D /r ib VBLENDPD xmm1, xmm2, xmm3/m128, imm8</td>\n<td>RVMI</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Select packed double precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F3A.WIG 0D /r ib VBLENDPD ymm1, ymm2, ymm3/m256, imm8</td>\n<td>RVMI</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Select packed double precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RMI</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVMI</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8[3:0]</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Double-precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [3:0] determine whether the corresponding double precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is ”1”, then the double precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.</p>\n<p>VEX.128 encoded version: the first source operand is an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"blendpd--128-bit-legacy-sse-version-\">BLENDPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#blendpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0)THEN DEST[63:0] := DEST[63:0]\n    ELSE DEST [63:0] := SRC[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := DEST[127:64]\n    ELSE DEST [127:64] := SRC[127:64] FI\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vblendpd--vex-128-encoded-version-\">VBLENDPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vblendpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0)THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vblendpd--vex-256-encoded-version-\">VBLENDPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vblendpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0)THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (IMM8[1] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nIF (IMM8[2] = 0) THEN DEST[191:128] := SRC1[191:128]\n    ELSE DEST [191:128] := SRC2[191:128] FI\nIF (IMM8[3] = 0) THEN DEST[255:192] := SRC1[255:192]\n    ELSE DEST [255:192] := SRC2[255:192] FI\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLENDPD __m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask);\n</pre>\n<pre>VBLENDPD __m256d _mm256_blend_pd (__m256d a, __m256d b, const int mask);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blendpd"},"/x86/blendps":{"name":"BLENDPS","description":"Blend Packed Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLENDPS\n\t\t— Blend Packed Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLENDPS\n\t\t— Blend Packed Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 3A 0C /r ib BLENDPS xmm1, xmm2/m128, imm8</td>\n<td>RMI</td>\n<td>V/V</td>\n<td>SSE4_1</td>\n<td>Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F3A.WIG 0C /r ib VBLENDPS xmm1, xmm2, xmm3/m128, imm8</td>\n<td>RVMI</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Select packed single precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1.</td></tr>\n<tr>\n<td>VEX.256.66.0F3A.WIG 0C /r ib VBLENDPS ymm1, ymm2, ymm3/m256, imm8</td>\n<td>RVMI</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Select packed single precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RMI</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVMI</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Packed single precision floating-point values from the second source operand (third operand) are conditionally merged with values from the first source operand (second operand) and written to the destination operand (first operand). The immediate bits [7:0] determine whether the corresponding single precision floating-point value in the destination is copied from the second source or first source. If a bit in the mask, corresponding to a word, is “1”, then the single precision floating-point value in the second source operand is copied, else the value in the first source operand is copied.</p>\n<p>128-bit Legacy SSE version: The second source can be an XMM register or an 128-bit memory location. The destination is not distinct from the first source XMM register and the upper bits (MAXVL-1:128) of the corresponding YMM register destination are unmodified.</p>\n<p>VEX.128 encoded version: The first source operand an XMM register. The second source operand is an XMM register or 128-bit memory location. The destination operand is an XMM register. The upper bits (MAXVL-1:128) of the corresponding YMM register destination are zeroed.</p>\n<p>VEX.256 encoded version: The first source operand is a YMM register. The second source operand can be a YMM register or a 256-bit memory location. The destination operand is a YMM register.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"blendps--128-bit-legacy-sse-version-\">BLENDPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#blendps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0) THEN DEST[31:0] :=DEST[31:0]\n    ELSE DEST [31:0] := SRC[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := DEST[63:32]\n    ELSE DEST [63:32] := SRC[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := DEST[95:64]\n    ELSE DEST [95:64] := SRC[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := DEST[127:96]\n    ELSE DEST [127:96] := SRC[127:96] FI\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vblendps--vex-128-encoded-version-\">VBLENDPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vblendps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0) THEN DEST[31:0] :=SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vblendps--vex-256-encoded-version-\">VBLENDPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vblendps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF (IMM8[0] = 0) THEN DEST[31:0] :=SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (IMM8[1] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (IMM8[2] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (IMM8[3] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nIF (IMM8[4] = 0) THEN DEST[159:128] := SRC1[159:128]\n    ELSE DEST [159:128] := SRC2[159:128] FI\nIF (IMM8[5] = 0) THEN DEST[191:160] := SRC1[191:160]\n    ELSE DEST [191:160] := SRC2[191:160] FI\nIF (IMM8[6] = 0) THEN DEST[223:192] := SRC1[223:192]\n    ELSE DEST [223:192] := SRC2[223:192] FI\nIF (IMM8[7] = 0) THEN DEST[255:224] := SRC1[255:224]\n    ELSE DEST [255:224] := SRC2[255:224] FI.\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLENDPS __m128 _mm_blend_ps (__m128 v1, __m128 v2, const int mask);\n</pre>\n<pre>VBLENDPS __m256 _mm256_blend_ps (__m256 a, __m256 b, const int mask);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blendps"},"/x86/blendvpd":{"name":"BLENDVPD","description":"Variable Blend Packed Double Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLENDVPD\n\t\t— Variable Blend Packed Double Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLENDVPD\n\t\t— Variable Blend Packed Double Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 15 /r BLENDVPD xmm1, xmm2/m128 , &lt;XMM0&gt;</td>\n<td>RM0</td>\n<td>V/V</td>\n<td>SSE4_1</td>\n<td>Select packed double precision floating-point values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F3A.W0 4B /r /is4 VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4</td>\n<td>RVMR</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Conditionally copy double precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4.</td></tr>\n<tr>\n<td>VEX.256.66.0F3A.W0 4B /r /is4 VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4</td>\n<td>RVMR</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Conditionally copy double precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM0</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>implicit XMM0</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVMR</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8[7:4]</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Conditionally copy each quadword data element of double precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each quadword element of the mask register.</p>\n<p>Each quadword element of the destination operand is copied from:</p>\n<ul>\n<li>the corresponding quadword element in the second source operand, if a mask bit is “1”; or</li>\n<li>the corresponding quadword element in the first source operand, if a mask bit is “0”</li></ul>\n<p>The register assignment of the implicit mask operand for BLENDVPD is defined to be the architectural register XMM0.</p>\n<p>128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPD with a VEX prefix will cause #UD.</p>\n<p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.</p>\n<p>VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.</p>\n<p>VBLENDVPD permits the mask to be any XMM or YMM register. In contrast, BLENDVPD treats XMM0 implicitly as the mask and do not support non-destructive destination operation.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"blendvpd--128-bit-legacy-sse-version-\">BLENDVPD (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#blendvpd--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := XMM0\nIF (MASK[63] = 0) THEN DEST[63:0] := DEST[63:0]\n    ELSE DEST [63:0] := SRC[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := DEST[127:64]\n    ELSE DEST [127:64] := SRC[127:64] FI\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vblendvpd--vex-128-encoded-version-\">VBLENDVPD (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vblendvpd--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vblendvpd--vex-256-encoded-version-\">VBLENDVPD (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vblendvpd--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := SRC3\nIF (MASK[63] = 0) THEN DEST[63:0] := SRC1[63:0]\n    ELSE DEST [63:0] := SRC2[63:0] FI\nIF (MASK[127] = 0) THEN DEST[127:64] := SRC1[127:64]\n    ELSE DEST [127:64] := SRC2[127:64] FI\nIF (MASK[191] = 0) THEN DEST[191:128] := SRC1[191:128]\n    ELSE DEST [191:128] := SRC2[191:128] FI\nIF (MASK[255] = 0) THEN DEST[255:192] := SRC1[255:192]\n    ELSE DEST [255:192] := SRC2[255:192] FI\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLENDVPD __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3);\n</pre>\n<pre>VBLENDVPD __m128 _mm_blendv_pd (__m128d a, __m128d b, __m128d mask);\n</pre>\n<pre>VBLENDVPD __m256 _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions,” additionally:</p>\n<table>\n<tr>\n<td>#UD</td>\n<td>If VEX.W = 1.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blendvpd"},"/x86/blendvps":{"name":"BLENDVPS","description":"Variable Blend Packed Single Precision Floating-Point Values","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLENDVPS\n\t\t— Variable Blend Packed Single Precision Floating-Point Values</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLENDVPS\n\t\t— Variable Blend Packed Single Precision Floating-Point Values</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>66 0F 38 14 /r BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;</td>\n<td>RM0</td>\n<td>V/V</td>\n<td>SSE4_1</td>\n<td>Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1.</td></tr>\n<tr>\n<td>VEX.128.66.0F3A.W0 4A /r /is4 VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4</td>\n<td>RVMR</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Conditionally copy single precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4.</td></tr>\n<tr>\n<td>VEX.256.66.0F3A.W0 4A /r /is4 VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4</td>\n<td>RVMR</td>\n<td>V/V</td>\n<td>AVX</td>\n<td>Conditionally copy single precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>RM0</td>\n<td>ModRM:reg (r, w)</td>\n<td>ModRM:r/m (r)</td>\n<td>implicit XMM0</td>\n<td>N/A</td></tr>\n<tr>\n<td>RVMR</td>\n<td>ModRM:reg (w)</td>\n<td>VEX.vvvv (r)</td>\n<td>ModRM:r/m (r)</td>\n<td>imm8[7:4]</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Conditionally copy each dword data element of single precision floating-point value from the second source operand and the first source operand depending on mask bits defined in the mask register operand. The mask bits are the most significant bit in each dword element of the mask register.</p>\n<p>Each quadword element of the destination operand is copied from:</p>\n<ul>\n<li>the corresponding dword element in the second source operand, if a mask bit is “1”; or</li>\n<li>the corresponding dword element in the first source operand, if a mask bit is “0”.</li></ul>\n<p>The register assignment of the implicit mask operand for BLENDVPS is defined to be the architectural register XMM0.</p>\n<p>128-bit Legacy SSE version: The first source operand and the destination operand is the same. Bits (MAXVL-1:128) of the corresponding YMM destination register remain unchanged. The mask register operand is implicitly defined to be the architectural register XMM0. An attempt to execute BLENDVPS with a VEX prefix will cause #UD.</p>\n<p>VEX.128 encoded version: The first source operand and the destination operand are XMM registers. The second source operand is an XMM register or 128-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. The upper bits (MAXVL-1:128) of the corresponding YMM register (destination register) are zeroed. VEX.W must be 0, otherwise, the instruction will #UD.</p>\n<p>VEX.256 encoded version: The first source operand and destination operand are YMM registers. The second source operand can be a YMM register or a 256-bit memory location. The mask operand is the third source register, and encoded in bits[7:4] of the immediate byte(imm8). The bits[3:0] of imm8 are ignored. In 32-bit mode, imm8[7] is ignored. VEX.W must be 0, otherwise, the instruction will #UD.</p>\n<p>VBLENDVPS permits the mask to be any XMM or YMM register. In contrast, BLENDVPS treats XMM0 implicitly as the mask and do not support non-destructive destination operation.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"blendvps--128-bit-legacy-sse-version-\">BLENDVPS (128-bit Legacy SSE Version)<a class=\"anchor\" href=\"#blendvps--128-bit-legacy-sse-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := XMM0\nIF (MASK[31] = 0) THEN DEST[31:0] := DEST[31:0]\n    ELSE DEST [31:0] := SRC[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := DEST[63:32]\n    ELSE DEST [63:32] := SRC[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := DEST[95:64]\n    ELSE DEST [95:64] := SRC[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := DEST[127:96]\n    ELSE DEST [127:96] := SRC[127:96] FI\nDEST[MAXVL-1:128] (Unmodified)\n</pre>\n<h3 id=\"vblendvps--vex-128-encoded-version-\">VBLENDVPS (VEX.128 Encoded Version)<a class=\"anchor\" href=\"#vblendvps--vex-128-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nDEST[MAXVL-1:128] := 0\n</pre>\n<h3 id=\"vblendvps--vex-256-encoded-version-\">VBLENDVPS (VEX.256 Encoded Version)<a class=\"anchor\" href=\"#vblendvps--vex-256-encoded-version-\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>MASK := SRC3\nIF (MASK[31] = 0) THEN DEST[31:0] := SRC1[31:0]\n    ELSE DEST [31:0] := SRC2[31:0] FI\nIF (MASK[63] = 0) THEN DEST[63:32] := SRC1[63:32]\n    ELSE DEST [63:32] := SRC2[63:32] FI\nIF (MASK[95] = 0) THEN DEST[95:64] := SRC1[95:64]\n    ELSE DEST [95:64] := SRC2[95:64] FI\nIF (MASK[127] = 0) THEN DEST[127:96] := SRC1[127:96]\n    ELSE DEST [127:96] := SRC2[127:96] FI\nIF (MASK[159] = 0) THEN DEST[159:128] := SRC1[159:128]\n    ELSE DEST [159:128] := SRC2[159:128] FI\nIF (MASK[191] = 0) THEN DEST[191:160] := SRC1[191:160]\n    ELSE DEST [191:160] := SRC2[191:160] FI\nIF (MASK[223] = 0) THEN DEST[223:192] := SRC1[223:192]\n    ELSE DEST [223:192] := SRC2[223:192] FI\nIF (MASK[255] = 0) THEN DEST[255:224] := SRC1[255:224]\n    ELSE DEST [255:224] := SRC2[255:224] FI\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLENDVPS __m128 _mm_blendv_ps(__m128 v1, __m128 v2, __m128 v3);\n</pre>\n<pre>VBLENDVPS __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask);\n</pre>\n<pre>VBLENDVPS __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-21</span>, “Type 4 Class Exception Conditions,” additionally:</p>\n<table>\n<tr>\n<td>#UD</td>\n<td>If VEX.W = 1.</td></tr></table><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blendvps"},"/x86/blsi":{"name":"BLSI","description":"Extract Lowest Set Isolated Bit","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLSI\n\t\t— Extract Lowest Set Isolated Bit</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLSI\n\t\t— Extract Lowest Set Isolated Bit</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>VEX.LZ.0F38.W0 F3 /3 BLSI r32, r/m32</td>\n<td>VM</td>\n<td>V/V</td>\n<td>BMI1</td>\n<td>Extract lowest set bit from r/m32 and set that bit in r32.</td></tr>\n<tr>\n<td>VEX.LZ.0F38.W1 F3 /3 BLSI r64, r/m64</td>\n<td>VM</td>\n<td>V/N.E.</td>\n<td>BMI1</td>\n<td>Extract lowest set bit from r/m64, and set that bit in r64.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>VM</td>\n<td>VEX.vvvv (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Extracts the lowest set bit from the source operand and set the corresponding bit in the destination register. All other bits in the destination operand are zeroed. If no bits are set in the source operand, BLSI sets all the bits in the destination to 0 and sets ZF and CF.</p>\n<p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>temp := (-SRC) bitwiseAND (SRC);\nSF := temp[OperandSize -1];\nZF := (temp = 0);\nIF SRC = 0\n    CF := 0;\nELSE\n    CF := 1;\nFI\nDEST := temp;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF and SF are updated based on the result. CF is set if the source is not zero. OF flags are cleared. AF and PF flags are undefined.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLSI unsigned __int32 _blsi_u32(unsigned __int32 src);\n</pre>\n<pre>BLSI unsigned __int64 _blsi_u64(unsigned __int64 src);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-29</span>, “Type 13 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blsi"},"/x86/blsmsk":{"name":"BLSMSK","description":"Get Mask Up to Lowest Set Bit","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLSMSK\n\t\t— Get Mask Up to Lowest Set Bit</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLSMSK\n\t\t— Get Mask Up to Lowest Set Bit</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>VEX.LZ.0F38.W0 F3 /2 BLSMSK r32, r/m32</td>\n<td>VM</td>\n<td>V/V</td>\n<td>BMI1</td>\n<td>Set all lower bits in r32 to “1” starting from bit 0 to lowest set bit in r/m32.</td></tr>\n<tr>\n<td>VEX.LZ.0F38.W1 F3 /2 BLSMSK r64, r/m64</td>\n<td>VM</td>\n<td>V/N.E.</td>\n<td>BMI1</td>\n<td>Set all lower bits in r64 to “1” starting from bit 0 to lowest set bit in r/m64.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>VM</td>\n<td>VEX.vvvv (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Sets all the lower bits of the destination operand to “1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.</p>\n<p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>temp := (SRC-1) XOR (SRC) ;\nSF := temp[OperandSize -1];\nZF := 0;\nIF SRC = 0\n    CF := 1;\nELSE\n    CF := 0;\nFI\nDEST := temp;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>SF is updated based on the result. CF is set if the source if zero. ZF and OF flags are cleared. AF and PF flag are undefined.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLSMSK unsigned __int32 _blsmsk_u32(unsigned __int32 src);\n</pre>\n<pre>BLSMSK unsigned __int64 _blsmsk_u64(unsigned __int64 src);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-29</span>, “Type 13 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blsmsk"},"/x86/blsr":{"name":"BLSR","description":"Reset Lowest Set Bit","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BLSR\n\t\t— Reset Lowest Set Bit</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BLSR\n\t\t— Reset Lowest Set Bit</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32-bit Mode</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>VEX.LZ.0F38.W0 F3 /1 BLSR r32, r/m32</td>\n<td>VM</td>\n<td>V/V</td>\n<td>BMI1</td>\n<td>Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.</td></tr>\n<tr>\n<td>VEX.LZ.0F38.W1 F3 /1 BLSR r64, r/m64</td>\n<td>VM</td>\n<td>V/N.E.</td>\n<td>BMI1</td>\n<td>Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th>\n<th>Operand 4</th></tr>\n<tr>\n<td>VM</td>\n<td>VEX.vvvv (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Copies all bits from the source operand to the destination operand and resets (=0) the bit position in the destination operand that corresponds to the lowest set bit of the source operand. If the source operand is zero BLSR sets CF.</p>\n<p>This instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>temp := (SRC-1) bitwiseAND ( SRC );\nSF := temp[OperandSize -1];\nZF := (temp = 0);\nIF SRC = 0\n    CF := 1;\nELSE\n    CF := 0;\nFI\nDEST := temp;\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>ZF and SF flags are updated based on the result. CF is set if the source is zero. OF flag is cleared. AF and PF flags are undefined.</p>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BLSR unsigned __int32 _blsr_u32(unsigned __int32 src);\n</pre>\n<pre>BLSR unsigned __int64 _blsr_u64(unsigned __int64 src);\n</pre>\n<h2 class=\"exceptions\" id=\"simd-floating-point-exceptions\">SIMD Floating-Point Exceptions<a class=\"anchor\" href=\"#simd-floating-point-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None.</p>\n<h2 class=\"exceptions\" id=\"other-exceptions\">Other Exceptions<a class=\"anchor\" href=\"#other-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>See <span class=\"not-imported\">Table 2-29</span>, “Type 13 Class Exception Conditions.”</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/blsr"},"/x86/bndcl":{"name":"BNDCL","description":"Check Lower Bound","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BNDCL\n\t\t— Check Lower Bound</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BNDCL\n\t\t— Check Lower Bound</h1>\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F3 0F 1A /r BNDCL bnd, r/m32</td>\n<td>RM</td>\n<td>NE/V</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB.</td></tr>\n<tr>\n<td>F3 0F 1A /r BNDCL bnd, r/m64</td>\n<td>RM</td>\n<td>V/NE</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB.</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Compare the address in the second operand with the lower bound in bnd. The second operand can be either a register or memory operand. If the address is lower than the lower bound in bnd.LB, it will set BNDSTATUS to 01H and signal a #BR exception.</p>\n<p>This instruction does not cause any memory access, and does not read or write any flags.</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"bndcl-bnd--reg\">BNDCL BND, reg<a class=\"anchor\" href=\"#bndcl-bnd--reg\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF reg &lt; BND.LB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h3 id=\"bndcl-bnd--mem\">BNDCL BND, mem<a class=\"anchor\" href=\"#bndcl-bnd--mem\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>TEMP := LEA(mem);\nIF TEMP &lt; BND.LB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BNDCL void _bnd_chk_ptr_lbounds(const void *q)\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If lower bound check fails.</td></tr>\n<tr>\n<td rowspan=\"4\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 67H prefix is not used and CS.D=0.</td></tr>\n<tr>\n<td>If 67H prefix is used and CS.D=1.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If lower bound check fails.</td></tr>\n<tr>\n<td rowspan=\"3\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 16-bit addressing is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If lower bound check fails.</td></tr>\n<tr>\n<td rowspan=\"3\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 16-bit addressing is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.</td></tr></table>\n<p>Same exceptions as in protected mode.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/bndcl"},"/x86/bndcu:bndcn":{"name":"BNDCN","description":"Check Upper Bound","html":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:svg=\"http://www.w3.org/2000/svg\" xmlns:x86=\"http://www.felixcloutier.com/x86\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"></link><title>BNDCU/BNDCN\n\t\t— Check Upper Bound</title></head><body><header><nav><ul><li><a href='/x86/'>Index</a></li><li>March 2023</li></ul></nav></header><h1>BNDCU/BNDCN\n\t\t— Check Upper Bound</h1>\n\n\n<table>\n<tr>\n<th>Opcode/Instruction</th>\n<th>Op/En</th>\n<th>64/32 bit Mode Support</th>\n<th>CPUID Feature Flag</th>\n<th>Description</th></tr>\n<tr>\n<td>F2 0F 1A /r BNDCU bnd, r/m32</td>\n<td>RM</td>\n<td>NE/V</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).</td></tr>\n<tr>\n<td>F2 0F 1A /r BNDCU bnd, r/m64</td>\n<td>RM</td>\n<td>V/NE</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form).</td></tr>\n<tr>\n<td>F2 0F 1B /r BNDCN bnd, r/m32</td>\n<td>RM</td>\n<td>NE/V</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).</td></tr>\n<tr>\n<td>F2 0F 1B /r BNDCN bnd, r/m64</td>\n<td>RM</td>\n<td>V/NE</td>\n<td>MPX</td>\n<td>Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form).</td></tr></table>\n<h2 id=\"instruction-operand-encoding\">Instruction Operand Encoding<a class=\"anchor\" href=\"#instruction-operand-encoding\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<th>Op/En</th>\n<th>Operand 1</th>\n<th>Operand 2</th>\n<th>Operand 3</th></tr>\n<tr>\n<td>RM</td>\n<td>ModRM:reg (w)</td>\n<td>ModRM:r/m (r)</td>\n<td>N/A</td></tr></table>\n<h2 id=\"description\">Description<a class=\"anchor\" href=\"#description\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Compare the address in the second operand with the upper bound in bnd. The second operand can be either a register or a memory operand. If the address is higher than the upper bound in bnd.UB, it will set BNDSTATUS to 01H and signal a #BR exception.</p>\n<p>BNDCU perform 1’s complement operation on the upper bound of bnd first before proceeding with address comparison. BNDCN perform address comparison directly using the upper bound in bnd that is already reverted out of 1’s complement form.</p>\n<p>This instruction does not cause any memory access, and does not read or write any flags.</p>\n<p>Effective address computation of m32/64 has identical behavior to LEA</p>\n<h2 id=\"operation\">Operation<a class=\"anchor\" href=\"#operation\">\n\t\t\t¶\n\t\t</a></h2>\n<h3 id=\"bndcu-bnd--reg\">BNDCU BND, reg<a class=\"anchor\" href=\"#bndcu-bnd--reg\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF reg &gt; NOT(BND.UB) Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h3 id=\"bndcu-bnd--mem\">BNDCU BND, mem<a class=\"anchor\" href=\"#bndcu-bnd--mem\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>TEMP := LEA(mem);\nIF TEMP &gt; NOT(BND.UB) Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h3 id=\"bndcn-bnd--reg\">BNDCN BND, reg<a class=\"anchor\" href=\"#bndcn-bnd--reg\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>IF reg &gt; BND.UB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h3 id=\"bndcn-bnd--mem\">BNDCN BND, mem<a class=\"anchor\" href=\"#bndcn-bnd--mem\">\n\t\t\t¶\n\t\t</a></h3>\n<pre>TEMP := LEA(mem);\nIF TEMP &gt; BND.UB Then\n    BNDSTATUS := 01H;\n    #BR;\nFI;\n</pre>\n<h2 id=\"intel-c-c++-compiler-intrinsic-equivalent\">Intel C/C++ Compiler Intrinsic Equivalent<a class=\"anchor\" href=\"#intel-c-c++-compiler-intrinsic-equivalent\">\n\t\t\t¶\n\t\t</a></h2>\n<pre>BNDCU .void _bnd_chk_ptr_ubounds(const void *q)\n</pre>\n<h2 id=\"flags-affected\">Flags Affected<a class=\"anchor\" href=\"#flags-affected\">\n\t\t\t¶\n\t\t</a></h2>\n<p>None</p>\n<h2 class=\"exceptions\" id=\"protected-mode-exceptions\">Protected Mode Exceptions<a class=\"anchor\" href=\"#protected-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If upper bound check fails.</td></tr>\n<tr>\n<td rowspan=\"4\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 67H prefix is not used and CS.D=0.</td></tr>\n<tr>\n<td>If 67H prefix is used and CS.D=1.</td></tr></table>\n<h2 class=\"exceptions\" id=\"real-address-mode-exceptions\">Real-Address Mode Exceptions<a class=\"anchor\" href=\"#real-address-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If upper bound check fails.</td></tr>\n<tr>\n<td rowspan=\"3\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 16-bit addressing is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"virtual-8086-mode-exceptions\">Virtual-8086 Mode Exceptions<a class=\"anchor\" href=\"#virtual-8086-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#BR</td>\n<td>If upper bound check fails.</td></tr>\n<tr>\n<td rowspan=\"3\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If ModRM.r/m encodes BND4-BND7 when Intel MPX is enabled.</td></tr>\n<tr>\n<td>If 16-bit addressing is used.</td></tr></table>\n<h2 class=\"exceptions\" id=\"compatibility-mode-exceptions\">Compatibility Mode Exceptions<a class=\"anchor\" href=\"#compatibility-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<p>Same exceptions as in protected mode.</p>\n<h2 class=\"exceptions\" id=\"64-bit-mode-exceptions\">64-Bit Mode Exceptions<a class=\"anchor\" href=\"#64-bit-mode-exceptions\">\n\t\t\t¶\n\t\t</a></h2>\n<table>\n<tr>\n<td>#UD</td>\n<td>If ModRM.r/m and REX encodes BND4-BND15 when Intel MPX is enabled.</td></tr></table>\n<p>Same exceptions as in protected mode.</p><footer><p>\n\t\tThis UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be\n\t\tinc<span style=\"opacity: 0.2\">omp</span>lete or b<sub>r</sub>oke<sub>n</sub> in various obvious or non-obvious\n\t\tways. Refer to <a href=\"https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4\">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a> for anything serious.\n\t</p></footer></body></html>\n","href":"/x86/bndcu:bndcn"}}