{"name":"AESENC","href":"/x86/aesenc","description":"Perform One Round of an AES Encryption Flow","instructionTypes":[{"opCode":"66 0F 38 DC /r AESENC xmm1, xmm2/m128","instruction":"A","operatorEncoding":"V/V","supports64BitMode":"AES","supportsCompatMode":"Perform one round of an AES encryption flow, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.","description":"VEX.128.66.0F38.WIG DC /r VAESENC xmm1, xmm2, xmm3/m128"}],"instructionOperandEncodings":[{"operatorEncoding":"A","operand1":"N/A","operand2":"ModRM:reg (r, w)","operand3":"ModRM:r/m (r)","operand4":"N/A"}],"longDescription":"This instruction performs a single round of an AES encryption flow using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESENC instruction for all but the last encryption rounds. For the last encryption round, use the AESENCCLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n\n","operation":"","flagsAffected":"","protectedModeExceptions":null,"realAddressModeExceptions":null,"virtual8086ModeExceptions":null,"compatibilityModeExceptions":null,"mode64BitExceptions":null}