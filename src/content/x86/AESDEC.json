{"name":"AESDEC","href":"/x86/aesdec","description":"Perform One Round of an AES Decryption Flow","instructionTypes":[{"opCode":"66 0F 38 DE /r AESDEC xmm1, xmm2/m128","instruction":"A","operatorEncoding":"V/V","supports64BitMode":"AES","supportsCompatMode":"Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, using one 128-bit data (state) from xmm1 with one 128-bit round key from xmm2/m128.","description":"VEX.128.66.0F38.WIG DE /r VAESDEC xmm1, xmm2, xmm3/m128"}],"instructionOperandEncodings":[{"operatorEncoding":"A","operand1":"N/A","operand2":"ModRM:reg (r, w)","operand3":"ModRM:r/m (r)","operand4":"N/A"}],"longDescription":"This instruction performs a single round of the AES decryption flow using the Equivalent Inverse Cipher, using one/two/four (depending on vector length) 128-bit data (state) from the first source operand with one/two/four (depending on vector length) round key(s) from the second source operand, and stores the result in the destination operand.\n\nUse the AESDEC instruction for all but the last decryption round. For the last decryption round, use the AESDECLAST instruction.\n\nVEX and EVEX encoded versions of the instruction allow 3-operand (non-destructive) operation. The legacy encoded versions of the instruction require that the first source operand and the destination operand are the same and must be an XMM register.\n\nThe EVEX encoded form of this instruction does not support memory fault suppression.\n\n","operation":"","flagsAffected":"","protectedModeExceptions":null,"realAddressModeExceptions":null,"virtual8086ModeExceptions":null,"compatibilityModeExceptions":null,"mode64BitExceptions":null}