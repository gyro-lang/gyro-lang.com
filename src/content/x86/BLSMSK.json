{"name":"BLSMSK","href":"/x86/blsmsk","description":"Get Mask Up to Lowest Set Bit","instructionTypes":[{"opCode":"VEX.LZ.0F38.W0 F3 /2 BLSMSK r32, r/m32","instruction":"VM","operatorEncoding":"V/V","supports64BitMode":"BMI1","supportsCompatMode":"Set all lower bits in r32 to “1” starting from bit 0 to lowest set bit in r/m32.","description":"VEX.LZ.0F38.W1 F3 /2 BLSMSK r64, r/m64"}],"instructionOperandEncodings":[{"operatorEncoding":"VM","operand1":"VEX.vvvv (w)","operand2":"ModRM:r/m (r)","operand3":"N/A","operand4":"N/A"}],"longDescription":"Sets all the lower bits of the destination operand to “1” up to and including lowest set bit (=1) in the source operand. If source operand is zero, BLSMSK sets all bits of the destination operand to 1 and also sets CF to 1.\n\nThis instruction is not supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode. In 64-bit mode operand size 64 requires VEX.W1. VEX.W1 is ignored in non-64-bit modes. An attempt to execute this instruction with VEX.L not equal to 0 will cause #UD.\n\n","operation":"temp := (SRC-1) XOR (SRC) ;\nSF := temp[OperandSize -1];\nZF := 0;\nIF SRC = 0\n    CF := 1;\nELSE\n    CF := 0;\nFI\nDEST := temp;\n","flagsAffected":"SF is updated based on the result. CF is set if the source if zero. ZF and OF flags are cleared. AF and PF flag are undefined.","protectedModeExceptions":null,"realAddressModeExceptions":null,"virtual8086ModeExceptions":null,"compatibilityModeExceptions":null,"mode64BitExceptions":null}