{"name":"ADDSS","href":"/x86/addss","description":"Add Scalar Single Precision Floating-Point Values","instructionTypes":[{"opCode":"F3 0F 58 /r ADDSS xmm1, xmm2/m32","instruction":"A","operatorEncoding":"V/V","supports64BitMode":"SSE","supportsCompatMode":"Add the low single precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1.","description":"VEX.LIG.F3.0F.WIG 58 /r VADDSS xmm1,xmm2, xmm3/m32"}],"instructionOperandEncodings":[{"operatorEncoding":"A","operand1":"N/A","operand2":"ModRM:reg (r, w)","operand3":"ModRM:r/m (r)","operand4":"N/A"}],"longDescription":"Adds the low single precision floating-point values from the second source operand and the first source operand, and stores the double precision floating-point result in the destination operand.\n\nThe second source operand can be an XMM register or a 64-bit memory location. The first source and destination operands are XMM registers.\n\n128-bit Legacy SSE version: The first source and destination operands are the same. Bits (MAXVL-1:32) of the corresponding the destination register remain unchanged.\n\nEVEX and VEX.128 encoded version: The first source operand is encoded by EVEX.vvvv/VEX.vvvv. Bits (127:32) of the XMM register destination are copied from corresponding bits in the first source operand. Bits (MAXVL-1:128) of the destination register are zeroed.\n\nEVEX version: The low doubleword element of the destination is updated according to the writemask.\n\nSoftware should ensure VADDSS is encoded with VEX.L=0. Encoding VADDSS with VEX.L=1 may encounter unpredictable behavior across different processor generations.\n\n","operation":"","flagsAffected":"","protectedModeExceptions":null,"realAddressModeExceptions":null,"virtual8086ModeExceptions":null,"compatibilityModeExceptions":null,"mode64BitExceptions":null}