{"name":"ADOX","href":"/x86/adox","description":"Unsigned Integer Addition of Two Operands With Overflow Flag","instructionTypes":[{"opCode":"F3 0F 38 F6 /r ADOX r32, r/m32","instruction":"RM","operatorEncoding":"V/V","supports64BitMode":"ADX","supportsCompatMode":"Unsigned addition of r32 with OF, r/m32 to r32, writes OF.","description":"F3 REX.w 0F 38 F6 /r ADOX r64, r/m64"}],"instructionOperandEncodings":[{"operatorEncoding":"RM","operand1":"ModRM:reg (r, w)","operand2":"ModRM:r/m (r)","operand3":"N/A","operand4":"N/A"}],"longDescription":"Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and the overflow-flag (OF) and stores the result in the destination operand. The destination operand is a general-purpose register, whereas the source operand can be a general-purpose register or memory location. The state of OF represents a carry from a previous addition. The instruction sets the OF flag with the carry generated by the unsigned addition of the operands.\n\nThe ADOX instruction is executed in the context of multi-precision addition, where we add a series of operands with a carry-chain. At the beginning of a chain of additions, we execute an instruction to zero the OF (e.g. XOR).\n\nThis instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.\n\nIn 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64-bits.\n\nADOX executes normally either inside or outside a transaction region.\n\nNote: ADOX defines the CF and OF flags differently than the ADD/ADC instructions as defined in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\n","operation":"IF OperandSize is 64-bit\n    THEN OF:DEST[63:0] := DEST[63:0] + SRC[63:0] + OF;\n    ELSE OF:DEST[31:0] := DEST[31:0] + SRC[31:0] + OF;\nFI;\n","flagsAffected":"OF is updated based on result. CF, SF, ZF, AF, and PF flags are unmodified.","protectedModeExceptions":"\n<tbody><tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td rowspan=\"2\">#GP(0)</td>\n<td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.</td></tr>\n<tr>\n<td>If the DS, ES, FS, or GS register is used to access memory and it contains a null segment selector.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></tbody>","realAddressModeExceptions":"\n<tbody><tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr></tbody>","virtual8086ModeExceptions":"\n<tbody><tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>For an illegal address in the SS segment.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></tbody>","compatibilityModeExceptions":null,"mode64BitExceptions":"\n<tbody><tr>\n<td rowspan=\"2\">#UD</td>\n<td>If the LOCK prefix is used.</td></tr>\n<tr>\n<td>If CPUID.(EAX=07H, ECX=0H):EBX.ADX[bit 19] = 0.</td></tr>\n<tr>\n<td>#SS(0)</td>\n<td>If a memory address referencing the SS segment is in a non-canonical form.</td></tr>\n<tr>\n<td>#GP(0)</td>\n<td>If the memory address is in a non-canonical form.</td></tr>\n<tr>\n<td>#PF(fault-code)</td>\n<td>For a page fault.</td></tr>\n<tr>\n<td>#AC(0)</td>\n<td>If alignment checking is enabled and an unaligned memory reference is made while the current privilege level is 3.</td></tr></tbody>"}